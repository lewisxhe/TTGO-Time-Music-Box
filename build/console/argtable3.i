# 1 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
# 1 "D:\\ESP32\\esp-idf-v3.1-rc1\\ESP32_PIC_A2DP\\build\\console//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
# 31 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
# 1 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.h" 1
# 34 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.h"
# 1 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/stdio.h" 1
# 29 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/stdio.h"
# 1 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/_ansi.h" 1
# 15 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/_ansi.h"
# 1 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/newlib.h" 1
# 16 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/_ansi.h" 2
# 1 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/config.h" 1



# 1 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/machine/ieeefp.h" 1
# 5 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/config.h" 2
# 1 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/features.h" 1
# 6 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/config.h" 2
# 189 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/config.h"
# 1 "D:/ESP32/esp-idf-v3.1-rc1/components/esp32/include/xtensa/config/core-isa.h" 1
# 190 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/config.h" 2
# 17 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/_ansi.h" 2
# 30 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/stdio.h" 2





# 1 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/cdefs.h" 1
# 43 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/cdefs.h"
# 1 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/machine/_default_types.h" 1
# 17 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/machine/_default_types.h"
typedef signed char __int8_t ;
typedef unsigned char __uint8_t ;


typedef signed short __int16_t;
typedef unsigned short __uint16_t;


typedef signed int __int32_t;
typedef unsigned int __uint32_t;


typedef signed long long __int64_t;
typedef unsigned long long __uint64_t;


typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;


typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;


typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;


typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;


typedef int __intptr_t;
typedef unsigned int __uintptr_t;
# 44 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/cdefs.h" 2

# 1 "c:\\msys32\\opt\\xtensa-esp32-elf\\lib\\gcc\\xtensa-esp32-elf\\5.2.0\\include\\stddef.h" 1 3 4
# 216 "c:\\msys32\\opt\\xtensa-esp32-elf\\lib\\gcc\\xtensa-esp32-elf\\5.2.0\\include\\stddef.h" 3 4

# 216 "c:\\msys32\\opt\\xtensa-esp32-elf\\lib\\gcc\\xtensa-esp32-elf\\5.2.0\\include\\stddef.h" 3 4
typedef unsigned int size_t;
# 46 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/cdefs.h" 2
# 36 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/stdio.h" 2
# 1 "c:\\msys32\\opt\\xtensa-esp32-elf\\lib\\gcc\\xtensa-esp32-elf\\5.2.0\\include\\stddef.h" 1 3 4
# 149 "c:\\msys32\\opt\\xtensa-esp32-elf\\lib\\gcc\\xtensa-esp32-elf\\5.2.0\\include\\stddef.h" 3 4
typedef int ptrdiff_t;
# 328 "c:\\msys32\\opt\\xtensa-esp32-elf\\lib\\gcc\\xtensa-esp32-elf\\5.2.0\\include\\stddef.h" 3 4
typedef short unsigned int wchar_t;
# 37 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/stdio.h" 2


# 1 "c:\\msys32\\opt\\xtensa-esp32-elf\\lib\\gcc\\xtensa-esp32-elf\\5.2.0\\include\\stdarg.h" 1 3 4
# 40 "c:\\msys32\\opt\\xtensa-esp32-elf\\lib\\gcc\\xtensa-esp32-elf\\5.2.0\\include\\stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 40 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/stdio.h" 2







# 1 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/reent.h" 1
# 13 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/reent.h"
# 1 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/_ansi.h" 1
# 14 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/reent.h" 2
# 1 "c:\\msys32\\opt\\xtensa-esp32-elf\\lib\\gcc\\xtensa-esp32-elf\\5.2.0\\include\\stddef.h" 1 3 4
# 15 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/reent.h" 2
# 1 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/_types.h" 1
# 12 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/_types.h"
# 1 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/machine/_types.h" 1
# 13 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/_types.h" 2
# 1 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/lock.h" 1
# 11 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/lock.h"

# 11 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/lock.h"
typedef int _lock_t;
typedef _lock_t _LOCK_RECURSIVE_T;
typedef _lock_t _LOCK_T;
# 28 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/lock.h"
void _lock_init(_lock_t *lock);
void _lock_init_recursive(_lock_t *lock);
void _lock_close(_lock_t *lock);
void _lock_close_recursive(_lock_t *lock);
void _lock_acquire(_lock_t *lock);
void _lock_acquire_recursive(_lock_t *lock);
int _lock_try_acquire(_lock_t *lock);
int _lock_try_acquire_recursive(_lock_t *lock);
void _lock_release(_lock_t *lock);
void _lock_release_recursive(_lock_t *lock);
# 14 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/_types.h" 2


typedef long _off_t;



typedef short __dev_t;



typedef unsigned short __uid_t;


typedef unsigned short __gid_t;



__extension__ typedef long long _off64_t;







typedef long _fpos_t;
# 55 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/_types.h"
typedef signed int _ssize_t;
# 67 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/_types.h"
# 1 "c:\\msys32\\opt\\xtensa-esp32-elf\\lib\\gcc\\xtensa-esp32-elf\\5.2.0\\include\\stddef.h" 1 3 4
# 357 "c:\\msys32\\opt\\xtensa-esp32-elf\\lib\\gcc\\xtensa-esp32-elf\\5.2.0\\include\\stddef.h" 3 4

# 357 "c:\\msys32\\opt\\xtensa-esp32-elf\\lib\\gcc\\xtensa-esp32-elf\\5.2.0\\include\\stddef.h" 3 4
typedef unsigned int wint_t;
# 68 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/_types.h" 2




# 71 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/_types.h"
typedef struct
{
  int __count;
  union
  {
    wint_t __wch;
    unsigned char __wchb[4];
  } __value;
} _mbstate_t;



typedef _LOCK_RECURSIVE_T _flock_t;




typedef void *_iconv_t;
# 16 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/reent.h" 2






typedef unsigned long __ULong;
# 38 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/reent.h"
struct _reent;






struct _Bigint
{
  struct _Bigint *_next;
  int _k, _maxwds, _sign, _wds;
  __ULong _x[1];
};


struct __tm
{
  int __tm_sec;
  int __tm_min;
  int __tm_hour;
  int __tm_mday;
  int __tm_mon;
  int __tm_year;
  int __tm_wday;
  int __tm_yday;
  int __tm_isdst;
};







struct _on_exit_args {
 void * _fnargs[32];
 void * _dso_handle[32];

 __ULong _fntypes;


 __ULong _is_cxa;
};


struct _atexit {
 struct _atexit *_next;
 int _ind;
 void (*_fns[32])(void);
        struct _on_exit_args * _on_exit_args_ptr;
};
# 115 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/reent.h"
struct __sbuf {
 unsigned char *_base;
 int _size;
};
# 151 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/reent.h"
struct __sFILE_fake {
  unsigned char *_p;
  int _r;
  int _w;
  short _flags;
  short _file;
  struct __sbuf _bf;
  int _lbfsize;

  struct _reent *_data;
};




extern void __sinit (struct _reent *);
# 179 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/reent.h"
struct __sFILE {
  unsigned char *_p;
  int _r;
  int _w;
  short _flags;
  short _file;
  struct __sbuf _bf;
  int _lbfsize;


  struct _reent *_data;



  void * _cookie;

  int (* _read) (struct _reent *, void *, char *, int)
                                          ;
  int (* _write) (struct _reent *, void *, const char *, int)

                                   ;
  _fpos_t (* _seek) (struct _reent *, void *, _fpos_t, int);
  int (* _close) (struct _reent *, void *);


  struct __sbuf _ub;
  unsigned char *_up;
  int _ur;


  unsigned char _ubuf[3];
  unsigned char _nbuf[1];


  struct __sbuf _lb;


  int _blksize;
  _off_t _offset;






  _flock_t _lock;

  _mbstate_t _mbstate;
  int _flags2;
};
# 285 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/reent.h"
typedef struct __sFILE __FILE;



struct _glue
{
  struct _glue *_next;
  int _niobs;
  __FILE *_iobs;
};
# 317 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/reent.h"
struct _rand48 {
  unsigned short _seed[3];
  unsigned short _mult[3];
  unsigned short _add;


  __extension__ unsigned long long _rand_next;

};
# 342 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/reent.h"
struct _mprec
{

  struct _Bigint *_result;
  int _result_k;
  struct _Bigint *_p5s;
  struct _Bigint **_freelist;
};


struct _misc_reent
{

  char *_strtok_last;
  _mbstate_t _mblen_state;
  _mbstate_t _wctomb_state;
  _mbstate_t _mbtowc_state;
  char _l64a_buf[8];
  int _getdate_err;
  _mbstate_t _mbrlen_state;
  _mbstate_t _mbrtowc_state;
  _mbstate_t _mbsrtowcs_state;
  _mbstate_t _wcrtomb_state;
  _mbstate_t _wcsrtombs_state;
};



struct _reent
{


  int _errno;




  __FILE *_stdin, *_stdout, *_stderr;

  int _inc;

  char *_emergency;

  int __sdidinit;

  int _current_category;
  const char *_current_locale;

  struct _mprec *_mp;

  void (* __cleanup) (struct _reent *);

  int _gamma_signgam;


  int _cvtlen;
  char *_cvtbuf;

  struct _rand48 *_r48;
  struct __tm *_localtime_buf;
  char *_asctime_buf;


  void (**(_sig_func))(int);



  struct _atexit *_atexit;
  struct _atexit _atexit0;


  struct _glue __sglue;
  __FILE *__sf;
  struct _misc_reent *_misc;
  char *_signal_buf;
};

extern const struct __sFILE_fake __sf_fake_stdin;
extern const struct __sFILE_fake __sf_fake_stdout;
extern const struct __sFILE_fake __sf_fake_stderr;
# 458 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/reent.h"
extern void esp_reent_init(struct _reent* reent);
# 771 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/reent.h"
extern struct _reent *_global_impure_ptr ;

void _reclaim_reent (struct _reent *);





  struct _reent * __getreent (void);
# 48 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/stdio.h" 2
# 1 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/types.h" 1
# 69 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/types.h"
# 1 "c:\\msys32\\opt\\xtensa-esp32-elf\\lib\\gcc\\xtensa-esp32-elf\\5.2.0\\include\\stddef.h" 1 3 4
# 70 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/types.h" 2
# 1 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/machine/types.h" 1
# 19 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/machine/types.h"
typedef long int __off_t;
typedef int __pid_t;

__extension__ typedef long long int __loff_t;
# 71 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/types.h" 2
# 93 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/types.h"
typedef unsigned char u_char;



typedef unsigned short u_short;



typedef unsigned int u_int;



typedef unsigned long u_long;





typedef unsigned short ushort;
typedef unsigned int uint;
typedef unsigned long ulong;



typedef unsigned long clock_t;




typedef long time_t;







struct timespec {
  time_t tv_sec;
  long tv_nsec;
};


struct itimerspec {
  struct timespec it_interval;
  struct timespec it_value;
};


typedef long daddr_t;



typedef char * caddr_t;
# 155 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/types.h"
typedef unsigned short ino_t;
# 184 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/types.h"
typedef _off_t off_t;
typedef __dev_t dev_t;
typedef __uid_t uid_t;
typedef __gid_t gid_t;





typedef int pid_t;







typedef long key_t;

typedef _ssize_t ssize_t;
# 217 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/types.h"
typedef unsigned int mode_t __attribute__ ((__mode__ (__SI__)));




typedef unsigned short nlink_t;
# 244 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/types.h"
typedef long fd_mask;







typedef struct _types_fd_set {
 fd_mask fds_bits[(((64)+(((sizeof (fd_mask) * 8))-1))/((sizeof (fd_mask) * 8)))];
} _types_fd_set;
# 275 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/types.h"
typedef unsigned long clockid_t;




typedef unsigned long timer_t;



typedef unsigned long useconds_t;
typedef long suseconds_t;
# 299 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/types.h"
# 1 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/sched.h" 1
# 46 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/sched.h"
struct sched_param {
  int sched_priority;
# 59 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/sched.h"
};

int sched_yield( void );
# 300 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/types.h" 2
# 308 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/types.h"
typedef __uint32_t pthread_t;
# 341 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/types.h"
typedef struct {
  int is_initialized;
  void *stackaddr;
  int stacksize;
  int contentionscope;
  int inheritsched;
  int schedpolicy;
  struct sched_param schedparam;
# 357 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/types.h"
  int detachstate;





} pthread_attr_t;
# 442 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/types.h"
typedef __uint32_t pthread_mutex_t;

typedef struct {
  int is_initialized;
# 454 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/types.h"
  int type;

  int recursive;
} pthread_mutexattr_t;




typedef __uint32_t pthread_cond_t;

typedef struct {
  int is_initialized;



} pthread_condattr_t;



typedef __uint32_t pthread_key_t;

typedef struct {
  int is_initialized;
  int init_executed;
} pthread_once_t;
# 49 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/stdio.h" 2



typedef __FILE FILE;




typedef _fpos_t fpos_t;





# 1 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/stdio.h" 1
# 64 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/stdio.h" 2
# 164 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/stdio.h"
FILE * tmpfile (void);
char * tmpnam (char *);

char * tempnam (const char *, const char *);

int fclose (FILE *);
int fflush (FILE *);
FILE * freopen (const char *restrict, const char *restrict, FILE *restrict);
void setbuf (FILE *restrict, char *restrict);
int setvbuf (FILE *restrict, char *restrict, int, size_t);
int fprintf (FILE *restrict, const char *restrict, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
int fscanf (FILE *restrict, const char *restrict, ...) __attribute__ ((__format__ (__scanf__, 2, 3)))
                                                           ;
int printf (const char *restrict, ...) __attribute__ ((__format__ (__printf__, 1, 2)))
                                                            ;
int scanf (const char *restrict, ...) __attribute__ ((__format__ (__scanf__, 1, 2)))
                                                           ;
int sscanf (const char *restrict, const char *restrict, ...) __attribute__ ((__format__ (__scanf__, 2, 3)))
                                                           ;
int vfprintf (FILE *restrict, const char *restrict, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int vprintf (const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 1, 0)))
                                                            ;
int vsprintf (char *restrict, const char *restrict, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int fgetc (FILE *);
char * fgets (char *restrict, int, FILE *restrict);
int fputc (int, FILE *);
int fputs (const char *restrict, FILE *restrict);
int getc (FILE *);
int getchar (void);
char * gets (char *);
int putc (int, FILE *);
int putchar (int);
int puts (const char *);
int ungetc (int, FILE *);
size_t fread (void * restrict, size_t _size, size_t _n, FILE *restrict);
size_t fwrite (const void * restrict , size_t _size, size_t _n, FILE *);



int fgetpos (FILE *restrict, fpos_t *restrict);

int fseek (FILE *, long, int);



int fsetpos (FILE *, const fpos_t *);

long ftell ( FILE *);
void rewind (FILE *);
void clearerr (FILE *);
int feof (FILE *);
int ferror (FILE *);
void perror (const char *);

FILE * fopen (const char *restrict _name, const char *restrict _type);
int sprintf (char *restrict, const char *restrict, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
int remove (const char *);
int rename (const char *, const char *);
# 235 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/stdio.h"
int fseeko (FILE *, off_t, int);
off_t ftello ( FILE *);







int asiprintf (char **, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
char * asniprintf (char *, size_t *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
char * asnprintf (char *restrict, size_t *restrict, const char *restrict, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int asprintf (char **restrict, const char *restrict, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;

int diprintf (int, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;

int fiprintf (FILE *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
int fiscanf (FILE *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)))
                                                           ;
int iprintf (const char *, ...) __attribute__ ((__format__ (__printf__, 1, 2)))
                                                            ;
int iscanf (const char *, ...) __attribute__ ((__format__ (__scanf__, 1, 2)))
                                                           ;
int siprintf (char *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
int siscanf (const char *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)))
                                                           ;
int snprintf (char *restrict, size_t, const char *restrict, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int sniprintf (char *, size_t, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int vasiprintf (char **, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
char * vasniprintf (char *, size_t *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
char * vasnprintf (char *, size_t *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int vasprintf (char **, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int vdiprintf (int, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int vfiprintf (FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int vfiscanf (FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)))
                                                           ;
int vfscanf (FILE *restrict, const char *restrict, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)))
                                                           ;
int viprintf (const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 1, 0)))
                                                            ;
int viscanf (const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 1, 0)))
                                                           ;
int vscanf (const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 1, 0)))
                                                           ;
int vsiprintf (char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int vsiscanf (const char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)))
                                                           ;
int vsniprintf (char *, size_t, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int vsnprintf (char *restrict, size_t, const char *restrict, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int vsscanf (const char *restrict, const char *restrict, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)))
                                                           ;
# 313 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/stdio.h"
FILE * fdopen (int, const char *);

int fileno (FILE *);
int getw (FILE *);
int pclose (FILE *);
FILE * popen (const char *, const char *);
int putw (int, FILE *);
void setbuffer (FILE *, char *, int);
int setlinebuf (FILE *);
int getc_unlocked (FILE *);
int getchar_unlocked (void);
void flockfile (FILE *);
int ftrylockfile (FILE *);
void funlockfile (FILE *);
int putc_unlocked (int, FILE *);
int putchar_unlocked (int);
# 338 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/stdio.h"
int dprintf (int, const char *restrict, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;

FILE * fmemopen (void *restrict, size_t, const char *restrict);


FILE * open_memstream (char **, size_t *);

int renameat (int, const char *, int, const char *);

int vdprintf (int, const char *restrict, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;







int _asiprintf_r (struct _reent *, char **, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
char * _asniprintf_r (struct _reent *, char *, size_t *, const char *, ...) __attribute__ ((__format__ (__printf__, 4, 5)))
                                                            ;
char * _asnprintf_r (struct _reent *, char *restrict, size_t *restrict, const char *restrict, ...) __attribute__ ((__format__ (__printf__, 4, 5)))
                                                            ;
int _asprintf_r (struct _reent *, char **restrict, const char *restrict, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _diprintf_r (struct _reent *, int, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _dprintf_r (struct _reent *, int, const char *restrict, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _fclose_r (struct _reent *, FILE *);
int _fcloseall_r (struct _reent *);
FILE * _fdopen_r (struct _reent *, int, const char *);
int _fflush_r (struct _reent *, FILE *);
int _fgetc_r (struct _reent *, FILE *);
int _fgetc_unlocked_r (struct _reent *, FILE *);
char * _fgets_r (struct _reent *, char *restrict, int, FILE *restrict);
char * _fgets_unlocked_r (struct _reent *, char *restrict, int, FILE *restrict);




int _fgetpos_r (struct _reent *, FILE *, fpos_t *);
int _fsetpos_r (struct _reent *, FILE *, const fpos_t *);

int _fiprintf_r (struct _reent *, FILE *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _fiscanf_r (struct _reent *, FILE *, const char *, ...) __attribute__ ((__format__ (__scanf__, 3, 4)))
                                                           ;
FILE * _fmemopen_r (struct _reent *, void *restrict, size_t, const char *restrict);
FILE * _fopen_r (struct _reent *, const char *restrict, const char *restrict);
FILE * _freopen_r (struct _reent *, const char *restrict, const char *restrict, FILE *restrict);
int _fprintf_r (struct _reent *, FILE *restrict, const char *restrict, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _fpurge_r (struct _reent *, FILE *);
int _fputc_r (struct _reent *, int, FILE *);
int _fputc_unlocked_r (struct _reent *, int, FILE *);
int _fputs_r (struct _reent *, const char *restrict, FILE *restrict);
int _fputs_unlocked_r (struct _reent *, const char *restrict, FILE *restrict);
size_t _fread_r (struct _reent *, void * restrict, size_t _size, size_t _n, FILE *restrict);
size_t _fread_unlocked_r (struct _reent *, void * restrict, size_t _size, size_t _n, FILE *restrict);
int _fscanf_r (struct _reent *, FILE *restrict, const char *restrict, ...) __attribute__ ((__format__ (__scanf__, 3, 4)))
                                                           ;
int _fseek_r (struct _reent *, FILE *, long, int);
int _fseeko_r (struct _reent *, FILE *, _off_t, int);
long _ftell_r (struct _reent *, FILE *);
_off_t _ftello_r (struct _reent *, FILE *);
void _rewind_r (struct _reent *, FILE *);
size_t _fwrite_r (struct _reent *, const void * restrict, size_t _size, size_t _n, FILE *restrict);
size_t _fwrite_unlocked_r (struct _reent *, const void * restrict, size_t _size, size_t _n, FILE *restrict);
int _getc_r (struct _reent *, FILE *);
int _getc_unlocked_r (struct _reent *, FILE *);
int _getchar_r (struct _reent *);
int _getchar_unlocked_r (struct _reent *);
char * _gets_r (struct _reent *, char *);
int _iprintf_r (struct _reent *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
int _iscanf_r (struct _reent *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)))
                                                           ;
FILE * _open_memstream_r (struct _reent *, char **, size_t *);
void _perror_r (struct _reent *, const char *);
int _printf_r (struct _reent *, const char *restrict, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
int _putc_r (struct _reent *, int, FILE *);
int _putc_unlocked_r (struct _reent *, int, FILE *);
int _putchar_unlocked_r (struct _reent *, int);
int _putchar_r (struct _reent *, int);
int _puts_r (struct _reent *, const char *);
int _remove_r (struct _reent *, const char *);
int _rename_r (struct _reent *, const char *_old, const char *_new)
                                          ;
int _scanf_r (struct _reent *, const char *restrict, ...) __attribute__ ((__format__ (__scanf__, 2, 3)))
                                                           ;
int _siprintf_r (struct _reent *, char *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _siscanf_r (struct _reent *, const char *, const char *, ...) __attribute__ ((__format__ (__scanf__, 3, 4)))
                                                           ;
int _sniprintf_r (struct _reent *, char *, size_t, const char *, ...) __attribute__ ((__format__ (__printf__, 4, 5)))
                                                            ;
int _snprintf_r (struct _reent *, char *restrict, size_t, const char *restrict, ...) __attribute__ ((__format__ (__printf__, 4, 5)))
                                                            ;
int _sprintf_r (struct _reent *, char *restrict, const char *restrict, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _sscanf_r (struct _reent *, const char *restrict, const char *restrict, ...) __attribute__ ((__format__ (__scanf__, 3, 4)))
                                                           ;
char * _tempnam_r (struct _reent *, const char *, const char *);
FILE * _tmpfile_r (struct _reent *);
char * _tmpnam_r (struct _reent *, char *);
int _ungetc_r (struct _reent *, int, FILE *);
int _vasiprintf_r (struct _reent *, char **, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
char * _vasniprintf_r (struct _reent*, char *, size_t *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 4, 0)))
                                                            ;
char * _vasnprintf_r (struct _reent*, char *, size_t *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 4, 0)))
                                                            ;
int _vasprintf_r (struct _reent *, char **, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vdiprintf_r (struct _reent *, int, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vdprintf_r (struct _reent *, int, const char *restrict, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vfiprintf_r (struct _reent *, FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vfiscanf_r (struct _reent *, FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 3, 0)))
                                                           ;
int _vfprintf_r (struct _reent *, FILE *restrict, const char *restrict, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vfscanf_r (struct _reent *, FILE *restrict, const char *restrict, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 3, 0)))
                                                           ;
int _viprintf_r (struct _reent *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int _viscanf_r (struct _reent *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)))
                                                           ;
int _vprintf_r (struct _reent *, const char *restrict, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int _vscanf_r (struct _reent *, const char *restrict, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)))
                                                           ;
int _vsiprintf_r (struct _reent *, char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vsiscanf_r (struct _reent *, const char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 3, 0)))
                                                           ;
int _vsniprintf_r (struct _reent *, char *, size_t, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 4, 0)))
                                                            ;
int _vsnprintf_r (struct _reent *, char *restrict, size_t, const char *restrict, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 4, 0)))
                                                            ;
int _vsprintf_r (struct _reent *, char *restrict, const char *restrict, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vsscanf_r (struct _reent *, const char *restrict, const char *restrict, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 3, 0)))
                                                           ;



int fpurge (FILE *);
ssize_t __getdelim (char **, size_t *, int, FILE *);
ssize_t __getline (char **, size_t *, FILE *);


void clearerr_unlocked (FILE *);
int feof_unlocked (FILE *);
int ferror_unlocked (FILE *);
int fileno_unlocked (FILE *);
int fflush_unlocked (FILE *);
int fgetc_unlocked (FILE *);
int fputc_unlocked (int, FILE *);
size_t fread_unlocked (void * restrict, size_t _size, size_t _n, FILE *restrict);
size_t fwrite_unlocked (const void * restrict , size_t _size, size_t _n, FILE *);
# 538 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/stdio.h"
int __srget_r (struct _reent *, FILE *);
int __swbuf_r (struct _reent *, int, FILE *);
# 562 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/stdio.h"
FILE *funopen (const void * __cookie, int (*__readfn)(void * __cookie, char *__buf, int __n), int (*__writefn)(void * __cookie, const char *__buf, int __n), fpos_t (*__seekfn)(void * __cookie, fpos_t __off, int __whence), int (*__closefn)(void * __cookie))





                                   ;
FILE *_funopen_r (struct _reent *, const void * __cookie, int (*__readfn)(void * __cookie, char *__buf, int __n), int (*__writefn)(void * __cookie, const char *__buf, int __n), fpos_t (*__seekfn)(void * __cookie, fpos_t __off, int __whence), int (*__closefn)(void * __cookie))





                                   ;







typedef ssize_t cookie_read_function_t(void *__cookie, char *__buf, size_t __n);
typedef ssize_t cookie_write_function_t(void *__cookie, const char *__buf,
     size_t __n);




typedef int cookie_seek_function_t(void *__cookie, off_t *__off, int __whence);

typedef int cookie_close_function_t(void *__cookie);
typedef struct
{


  cookie_read_function_t *read;
  cookie_write_function_t *write;
  cookie_seek_function_t *seek;
  cookie_close_function_t *close;
} cookie_io_functions_t;
FILE *fopencookie (void *__cookie, const char *__mode, cookie_io_functions_t __functions)
                                                         ;
FILE *_fopencookie_r (struct _reent *, void *__cookie, const char *__mode, cookie_io_functions_t __functions)
                                                         ;
# 725 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/stdio.h"

# 35 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.h" 2
# 1 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/time.h" 1
# 15 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/time.h"
# 1 "c:\\msys32\\opt\\xtensa-esp32-elf\\lib\\gcc\\xtensa-esp32-elf\\5.2.0\\include\\stddef.h" 1 3 4
# 16 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/time.h" 2


# 1 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/machine/time.h" 1
# 19 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/time.h" 2
# 29 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/time.h"


struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;






};

clock_t clock (void);
double difftime (time_t _time2, time_t _time1);
time_t mktime (struct tm *_timeptr);
time_t time (time_t *_timer);

char *asctime (const struct tm *_tblock);
char *ctime (const time_t *_time);
struct tm *gmtime (const time_t *_timer);
struct tm *localtime (const time_t *_timer);

size_t strftime (char *restrict _s, size_t _maxsize, const char *restrict _fmt, const struct tm *restrict _t)

                                        ;

char *asctime_r (const struct tm *restrict, char *restrict)
                       ;
char *ctime_r (const time_t *, char *);
struct tm *gmtime_r (const time_t *restrict, struct tm *restrict)
                            ;
struct tm *localtime_r (const time_t *restrict, struct tm *restrict)
                            ;








char *strptime (const char *restrict, const char *restrict, struct tm *restrict)

                            ;
void tzset (void);
void _tzset_r (struct _reent *);

typedef struct __tzrule_struct
{
  char ch;
  int m;
  int n;
  int d;
  int s;
  time_t change;
  long offset;
} __tzrule_type;

typedef struct __tzinfo_struct
{
  int __tznorth;
  int __tzyear;
  __tzrule_type __tzrule[2];
} __tzinfo_type;

__tzinfo_type *__gettzinfo (void);
# 129 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/time.h"
extern long _timezone;
extern int _daylight;
extern char *_tzname[2];
# 36 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.h" 2
# 44 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.h"
enum
{
    ARG_TERMINATOR=0x1,
    ARG_HASVALUE=0x2,
    ARG_HASOPTVALUE=0x4
};

typedef void (arg_resetfn)(void *parent);
typedef int (arg_scanfn)(void *parent, const char *argval);
typedef int (arg_checkfn)(void *parent);
typedef void (arg_errorfn)(void *parent, FILE *fp, int error, const char *argval, const char *progname);
# 74 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.h"
struct arg_hdr
{
    char flag;
    const char *shortopts;
    const char *longopts;
    const char *datatype;
    const char *glossary;
    int mincount;
    int maxcount;
    void *parent;
    arg_resetfn *resetfn;
    arg_scanfn *scanfn;
    arg_checkfn *checkfn;
    arg_errorfn *errorfn;
    void *priv;
};

struct arg_rem
{
    struct arg_hdr hdr;
};

struct arg_lit
{
    struct arg_hdr hdr;
    int count;
};

struct arg_int
{
    struct arg_hdr hdr;
    int count;
    int *ival;
};

struct arg_dbl
{
    struct arg_hdr hdr;
    int count;
    double *dval;
};

struct arg_str
{
    struct arg_hdr hdr;
    int count;
    const char **sval;
};

struct arg_rex
{
    struct arg_hdr hdr;
    int count;
    const char **sval;
};

struct arg_file
{
    struct arg_hdr hdr;
    int count;
    const char **filename;
    const char **basename;
    const char **extension;
};

struct arg_date
{
    struct arg_hdr hdr;
    const char *format;
    int count;
    struct tm *tmval;
};

enum {ARG_ELIMIT=1, ARG_EMALLOC, ARG_ENOMATCH, ARG_ELONGOPT, ARG_EMISSARG};
struct arg_end
{
    struct arg_hdr hdr;
    int count;
    int *error;
    void **parent;
    const char **argval;
};




struct arg_rem* arg_rem(const char* datatype, const char* glossary);

struct arg_lit* arg_lit0(const char* shortopts,
    const char* longopts,
    const char* glossary);
struct arg_lit* arg_lit1(const char* shortopts,
    const char* longopts,
    const char *glossary);
struct arg_lit* arg_litn(const char* shortopts,
    const char* longopts,
    int mincount,
    int maxcount,
    const char *glossary);

struct arg_key* arg_key0(const char* keyword,
    int flags,
    const char* glossary);
struct arg_key* arg_key1(const char* keyword,
    int flags,
    const char* glossary);
struct arg_key* arg_keyn(const char* keyword,
    int flags,
    int mincount,
    int maxcount,
    const char* glossary);

struct arg_int* arg_int0(const char* shortopts,
    const char* longopts,
    const char* datatype,
    const char* glossary);
struct arg_int* arg_int1(const char* shortopts,
    const char* longopts,
    const char* datatype,
    const char *glossary);
struct arg_int* arg_intn(const char* shortopts,
    const char* longopts,
    const char *datatype,
    int mincount,
    int maxcount,
    const char *glossary);

struct arg_dbl* arg_dbl0(const char* shortopts,
    const char* longopts,
    const char* datatype,
    const char* glossary);
struct arg_dbl* arg_dbl1(const char* shortopts,
    const char* longopts,
    const char* datatype,
    const char *glossary);
struct arg_dbl* arg_dbln(const char* shortopts,
    const char* longopts,
    const char *datatype,
    int mincount,
    int maxcount,
    const char *glossary);

struct arg_str* arg_str0(const char* shortopts,
    const char* longopts,
    const char* datatype,
    const char* glossary);
struct arg_str* arg_str1(const char* shortopts,
    const char* longopts,
    const char* datatype,
    const char *glossary);
struct arg_str* arg_strn(const char* shortopts,
    const char* longopts,
    const char* datatype,
    int mincount,
    int maxcount,
    const char *glossary);

struct arg_rex* arg_rex0(const char* shortopts,
    const char* longopts,
    const char* pattern,
    const char* datatype,
    int flags,
    const char* glossary);
struct arg_rex* arg_rex1(const char* shortopts,
    const char* longopts,
    const char* pattern,
    const char* datatype,
    int flags,
    const char *glossary);
struct arg_rex* arg_rexn(const char* shortopts,
    const char* longopts,
    const char* pattern,
    const char* datatype,
    int mincount,
    int maxcount,
    int flags,
    const char *glossary);

struct arg_file* arg_file0(const char* shortopts,
    const char* longopts,
    const char* datatype,
    const char* glossary);
struct arg_file* arg_file1(const char* shortopts,
    const char* longopts,
    const char* datatype,
    const char *glossary);
struct arg_file* arg_filen(const char* shortopts,
    const char* longopts,
    const char* datatype,
    int mincount,
    int maxcount,
    const char *glossary);

struct arg_date* arg_date0(const char* shortopts,
    const char* longopts,
    const char* format,
    const char* datatype,
    const char* glossary);
struct arg_date* arg_date1(const char* shortopts,
    const char* longopts,
    const char* format,
    const char* datatype,
    const char *glossary);
struct arg_date* arg_daten(const char* shortopts,
    const char* longopts,
    const char* format,
    const char* datatype,
    int mincount,
    int maxcount,
    const char *glossary);

struct arg_end* arg_end(int maxerrors);



int arg_nullcheck(void **argtable);
int arg_parse(int argc, char **argv, void **argtable);
void arg_print_option(FILE *fp, const char *shortopts, const char *longopts, const char *datatype, const char *suffix);
void arg_print_syntax(FILE *fp, void **argtable, const char *suffix);
void arg_print_syntaxv(FILE *fp, void **argtable, const char *suffix);
void arg_print_glossary(FILE *fp, void **argtable, const char *format);
void arg_print_glossary_gnu(FILE *fp, void **argtable);
void arg_print_errors(FILE* fp, struct arg_end* end, const char* progname);
void arg_freetable(void **argtable, size_t n);
void arg_print_formatted(FILE *fp, const unsigned lmargin, const unsigned rmargin, const char *text);


void arg_free(void **argtable);
# 32 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 2
# 73 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
enum
{
    EMINCOUNT = 1,
    EMAXCOUNT,
    EBADINT,
    EOVERFLOW,
    EBADDOUBLE,
    EBADDATE,
    EREGNOMATCH
};
# 105 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
extern void dbg_printf(const char *fmt, ...);
# 143 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
# 1 "c:\\msys32\\opt\\xtensa-esp32-elf\\lib\\gcc\\xtensa-esp32-elf\\5.2.0\\include\\stdarg.h" 1 3 4
# 98 "c:\\msys32\\opt\\xtensa-esp32-elf\\lib\\gcc\\xtensa-esp32-elf\\5.2.0\\include\\stdarg.h" 3 4

# 98 "c:\\msys32\\opt\\xtensa-esp32-elf\\lib\\gcc\\xtensa-esp32-elf\\5.2.0\\include\\stdarg.h" 3 4
typedef __gnuc_va_list va_list;
# 144 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 2




# 147 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
void dbg_printf(const char *fmt, ...)
{
    va_list args;
    
# 150 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
   __builtin_va_start(
# 150 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
   args
# 150 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
   ,
# 150 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
   fmt
# 150 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
   )
# 150 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                      ;
    vfprintf(((__getreent())->_stderr), fmt, args);
    
# 152 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
   __builtin_va_end(
# 152 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
   args
# 152 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
   )
# 152 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
               ;
}
# 209 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
struct option {

 const char *name;




 int has_arg;

 int *flag;

 int val;
};





int getopt_long(int, char * const *, const char *,
     const struct option *, int *);
int getopt_long_only(int, char * const *, const char *,
     const struct option *, int *);


int getopt(int, char * const *, const char *);
int getsubopt(char **, char * const *, char **);

extern char *optarg;
extern int opterr;
extern int optind;
extern int optopt;
extern int optreset;
extern char *suboptarg;
# 304 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
# 1 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/errno.h" 1




typedef int error_t;



# 1 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/errno.h" 1
# 15 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/errno.h"
extern int *__errno (void);




extern const char * const _sys_errlist[];
extern int _sys_nerr;
# 10 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/errno.h" 2
# 305 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 2
# 1 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/stdlib.h" 1
# 10 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/stdlib.h"
# 1 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/machine/ieeefp.h" 1
# 11 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/stdlib.h" 2





# 1 "c:\\msys32\\opt\\xtensa-esp32-elf\\lib\\gcc\\xtensa-esp32-elf\\5.2.0\\include\\stddef.h" 1 3 4
# 17 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/stdlib.h" 2



# 1 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/machine/stdlib.h" 1
# 21 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/stdlib.h" 2

# 1 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/alloca.h" 1
# 23 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/stdlib.h" 2








typedef struct
{
  int quot;
  int rem;
} div_t;

typedef struct
{
  long quot;
  long rem;
} ldiv_t;




typedef struct
{
  long long int quot;
  long long int rem;
} lldiv_t;




typedef int (*__compar_fn_t) (const void *, const void *);
# 67 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/stdlib.h"
int __locale_mb_cur_max (void);



void abort (void) __attribute__ ((__noreturn__));
int abs (int);
int atexit (void (*__func)(void));
double atof (const char *__nptr);

float atoff (const char *__nptr);

int atoi (const char *__nptr);
int _atoi_r (struct _reent *, const char *__nptr);
long atol (const char *__nptr);
long _atol_r (struct _reent *, const char *__nptr);
void * bsearch (const void * __key, const void * __base, size_t __nmemb, size_t __size, __compar_fn_t _compar)



                                ;
void * calloc (size_t __nmemb, size_t __size) ;
div_t div (int __numer, int __denom);
void exit (int __status) __attribute__ ((__noreturn__));
void free (void *) ;
char * getenv (const char *__string);
char * _getenv_r (struct _reent *, const char *__string);
char * _findenv (const char *, int *);
char * _findenv_r (struct _reent *, const char *, int *);

extern char *suboptarg;
int getsubopt (char **, char * const *, char **);

long labs (long);
ldiv_t ldiv (long __numer, long __denom);
void * malloc (size_t __size) ;
int mblen (const char *, size_t);
int _mblen_r (struct _reent *, const char *, size_t, _mbstate_t *);
int mbtowc (wchar_t *restrict, const char *restrict, size_t);
int _mbtowc_r (struct _reent *, wchar_t *restrict, const char *restrict, size_t, _mbstate_t *);
int wctomb (char *, wchar_t);
int _wctomb_r (struct _reent *, char *, wchar_t, _mbstate_t *);
size_t mbstowcs (wchar_t *restrict, const char *restrict, size_t);
size_t _mbstowcs_r (struct _reent *, wchar_t *restrict, const char *restrict, size_t, _mbstate_t *);
size_t wcstombs (char *restrict, const wchar_t *restrict, size_t);
size_t _wcstombs_r (struct _reent *, char *restrict, const wchar_t *restrict, size_t, _mbstate_t *);


char * mkdtemp (char *);
int mkostemp (char *, int);
int mkostemps (char *, int, int);
int mkstemp (char *);
int mkstemps (char *, int);

char * mktemp (char *);




char * _mkdtemp_r (struct _reent *, char *);
int _mkostemp_r (struct _reent *, char *, int);
int _mkostemps_r (struct _reent *, char *, int, int);
int _mkstemp_r (struct _reent *, char *);
int _mkstemps_r (struct _reent *, char *, int);

char * _mktemp_r (struct _reent *, char *);




void qsort (void * __base, size_t __nmemb, size_t __size, __compar_fn_t _compar);
int rand (void);
void * realloc (void * __r, size_t __size) ;

void * reallocf (void * __r, size_t __size);
char * realpath (const char *restrict path, char *restrict resolved_path);

void srand (unsigned __seed);
double strtod (const char *restrict __n, char **restrict __end_PTR);
double _strtod_r (struct _reent *,const char *restrict __n, char **restrict __end_PTR);



float strtof (const char *restrict __n, char **restrict __end_PTR);







long strtol (const char *restrict __n, char **restrict __end_PTR, int __base);
long _strtol_r (struct _reent *,const char *restrict __n, char **restrict __end_PTR, int __base);
unsigned long strtoul (const char *restrict __n, char **restrict __end_PTR, int __base);
unsigned long _strtoul_r (struct _reent *,const char *restrict __n, char **restrict __end_PTR, int __base);

int system (const char *__string);


long a64l (const char *__input);
char * l64a (long __input);
char * _l64a_r (struct _reent *,long __input);
int on_exit (void (*__func)(int, void *),void * __arg);




void _Exit (int __status) __attribute__ ((__noreturn__));


int putenv (char *__string);
int _putenv_r (struct _reent *, char *__string);
void * _reallocf_r (struct _reent *, void *, size_t);
int setenv (const char *__string, const char *__value, int __overwrite);
int _setenv_r (struct _reent *, const char *__string, const char *__value, int __overwrite);

char * gcvt (double,int,char *);
char * gcvtf (float,int,char *);
char * fcvt (double,int,int *,int *);
char * fcvtf (float,int,int *,int *);
char * ecvt (double,int,int *,int *);
char * ecvtbuf (double, int, int*, int*, char *);
char * fcvtbuf (double, int, int*, int*, char *);
char * ecvtf (float,int,int *,int *);
char * dtoa (double, int, int, int *, int*, char**);

char * __itoa (int, char *, int);
char * __utoa (unsigned, char *, int);

char * itoa (int, char *, int);
char * utoa (unsigned, char *, int);
int rand_r (unsigned *__seed);

double drand48 (void);
double _drand48_r (struct _reent *);
double erand48 (unsigned short [3]);
double _erand48_r (struct _reent *, unsigned short [3]);
long jrand48 (unsigned short [3]);
long _jrand48_r (struct _reent *, unsigned short [3]);
void lcong48 (unsigned short [7]);
void _lcong48_r (struct _reent *, unsigned short [7]);
long lrand48 (void);
long _lrand48_r (struct _reent *);
long mrand48 (void);
long _mrand48_r (struct _reent *);
long nrand48 (unsigned short [3]);
long _nrand48_r (struct _reent *, unsigned short [3]);
unsigned short *
       seed48 (unsigned short [3]);
unsigned short *
       _seed48_r (struct _reent *, unsigned short [3]);
void srand48 (long);
void _srand48_r (struct _reent *, long);




long long atoll (const char *__nptr);


long long _atoll_r (struct _reent *, const char *__nptr);




long long llabs (long long);
lldiv_t lldiv (long long __numer, long long __denom);
long long strtoll (const char *restrict __n, char **restrict __end_PTR, int __base);


long long _strtoll_r (struct _reent *, const char *restrict __n, char **restrict __end_PTR, int __base);




unsigned long long strtoull (const char *restrict __n, char **restrict __end_PTR, int __base);


unsigned long long _strtoull_r (struct _reent *, const char *restrict __n, char **restrict __end_PTR, int __base);


void cfree (void *);
int unsetenv (const char *__string);
int _unsetenv_r (struct _reent *, const char *__string);
# 258 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/stdlib.h"
char * _dtoa_r (struct _reent *, double, int, int, int *, int*, char**);

void * _malloc_r (struct _reent *, size_t) ;
void * _calloc_r (struct _reent *, size_t, size_t) ;
void _free_r (struct _reent *, void *) ;
void * _realloc_r (struct _reent *, void *, size_t) ;
void _mstats_r (struct _reent *, char *);

int _system_r (struct _reent *, const char *);

void __eprintf (const char *, const char *, unsigned int, const char *);
# 291 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/stdlib.h"
extern long double strtold (const char *restrict, char **restrict);




# 306 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 2
# 1 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/string.h" 1
# 17 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/string.h"
# 1 "c:\\msys32\\opt\\xtensa-esp32-elf\\lib\\gcc\\xtensa-esp32-elf\\5.2.0\\include\\stddef.h" 1 3 4
# 18 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/string.h" 2



void * memchr (const void *, int, size_t);
int memcmp (const void *, const void *, size_t);
void * memcpy (void * restrict, const void * restrict, size_t);
void * memmove (void *, const void *, size_t);
void * memset (void *, int, size_t);
char *strcat (char *restrict, const char *restrict);
char *strchr (const char *, int);
int strcmp (const char *, const char *);
int strcoll (const char *, const char *);
char *strcpy (char *restrict, const char *restrict);
size_t strcspn (const char *, const char *);
char *strerror (int);
size_t strlen (const char *);
char *strncat (char *restrict, const char *restrict, size_t);
int strncmp (const char *, const char *, size_t);
char *strncpy (char *restrict, const char *restrict, size_t);
char *strpbrk (const char *, const char *);
char *strrchr (const char *, int);
size_t strspn (const char *, const char *);
char *strstr (const char *, const char *);

char *strtok (char *restrict, const char *restrict);

size_t strxfrm (char *restrict, const char *restrict, size_t);


char *strtok_r (char *restrict, const char *restrict, char **restrict);


int bcmp (const void *, const void *, size_t);
void bcopy (const void *, void *, size_t);
void bzero (void *, size_t);
int ffs (int);
char *index (const char *, int);


void * memccpy (void * restrict, const void * restrict, int, size_t);





void * memrchr (const void *, int, size_t);




char *rindex (const char *, int);

char *stpcpy (char *restrict, const char *restrict);
char *stpncpy (char *restrict, const char *restrict, size_t);

int strcasecmp (const char *, const char *);






char *strdup (const char *);


char *_strdup_r (struct _reent *, const char *);


char *strndup (const char *, size_t);



char *_strndup_r (struct _reent *, const char *, size_t);
# 106 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/string.h"
int strerror_r (int, char *, size_t)
             __asm__ ("" "__xpg_strerror_r");







char * _strerror_r (struct _reent *, int, int, int *);


size_t strlcat (char *, const char *, size_t);
size_t strlcpy (char *, const char *, size_t);


int strncasecmp (const char *, const char *, size_t);



size_t strnlen (const char *, size_t);


char *strsep (char **, const char *);







char *strlwr (char *);
char *strupr (char *);



char *strsignal (int __signo);
# 163 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/string.h"
# 1 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/sys/string.h" 1
# 164 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/string.h" 2


# 307 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 2
# 845 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
char * arg_strptime(const char *buf, const char *fmt, struct tm *tm);


static void arg_date_resetfn(struct arg_date *parent)
{
    do { if (0) dbg_printf ("%s:resetfn(%p)\n", "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c", parent); } while (0);
    parent->count = 0;
}


static int arg_date_scanfn(struct arg_date *parent, const char *argval)
{
    int errorcode = 0;

    if (parent->count == parent->hdr.maxcount)
    {
        errorcode = EMAXCOUNT;
    }
    else if (!argval)
    {

        parent->count++;
    }
    else
    {
        const char *pend;
        struct tm tm = parent->tmval[parent->count];


        pend = arg_strptime(argval, parent->format, &tm);
        if (pend && pend[0] == '\0')
            parent->tmval[parent->count++] = tm;
        else
            errorcode = EBADDATE;
    }

    do { if (0) dbg_printf ("%s:scanfn(%p) returns %d\n", "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c", parent, errorcode); } while (0);
    return errorcode;
}


static int arg_date_checkfn(struct arg_date *parent)
{
    int errorcode = (parent->count < parent->hdr.mincount) ? EMINCOUNT : 0;

    do { if (0) dbg_printf ("%s:checkfn(%p) returns %d\n", "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c", parent, errorcode); } while (0);
    return errorcode;
}


static void arg_date_errorfn(
    struct arg_date *parent,
    FILE *fp,
    int errorcode,
    const char *argval,
    const char *progname)
{
    const char *shortopts = parent->hdr.shortopts;
    const char *longopts = parent->hdr.longopts;
    const char *datatype = parent->hdr.datatype;


    argval = argval ? argval : "";

    fprintf(fp, "%s: ", progname);
    switch(errorcode)
    {
    case EMINCOUNT:
        fputs("missing option ", fp);
        arg_print_option(fp, shortopts, longopts, datatype, "\n");
        break;

    case EMAXCOUNT:
        fputs("excess option ", fp);
        arg_print_option(fp, shortopts, longopts, argval, "\n");
        break;

    case EBADDATE:
    {
        struct tm tm;
        char buff[200];

        fprintf(fp, "illegal timestamp format \"%s\"\n", argval);
        memset(&tm, 0, sizeof(tm));
        arg_strptime("1999-12-31 23:59:59", "%F %H:%M:%S", &tm);
        strftime(buff, sizeof(buff), parent->format, &tm);
        printf("correct format is \"%s\"\n", buff);
        break;
    }
    }
}


struct arg_date * arg_date0(
    const char * shortopts,
    const char * longopts,
    const char * format,
    const char *datatype,
    const char *glossary)
{
    return arg_daten(shortopts, longopts, format, datatype, 0, 1, glossary);
}


struct arg_date * arg_date1(
    const char * shortopts,
    const char * longopts,
    const char * format,
    const char *datatype,
    const char *glossary)
{
    return arg_daten(shortopts, longopts, format, datatype, 1, 1, glossary);
}


struct arg_date * arg_daten(
    const char * shortopts,
    const char * longopts,
    const char * format,
    const char *datatype,
    int mincount,
    int maxcount,
    const char *glossary)
{
    size_t nbytes;
    struct arg_date *result;


    maxcount = (maxcount < mincount) ? mincount : maxcount;


    if (!format)
        format = "%x";

    nbytes = sizeof(struct arg_date)
        + maxcount * sizeof(struct tm);



    result = (struct arg_date *)calloc(1, nbytes);
    if (result)
    {

        result->hdr.flag = ARG_HASVALUE;
        result->hdr.shortopts = shortopts;
        result->hdr.longopts = longopts;
        result->hdr.datatype = datatype ? datatype : format;
        result->hdr.glossary = glossary;
        result->hdr.mincount = mincount;
        result->hdr.maxcount = maxcount;
        result->hdr.parent = result;
        result->hdr.resetfn = (arg_resetfn *)arg_date_resetfn;
        result->hdr.scanfn = (arg_scanfn *)arg_date_scanfn;
        result->hdr.checkfn = (arg_checkfn *)arg_date_checkfn;
        result->hdr.errorfn = (arg_errorfn *)arg_date_errorfn;


        result->tmval = (struct tm *)(result + 1);


        result->count = 0;
        result->format = format;
    }

    do { if (0) dbg_printf ("arg_daten() returns %p\n", result); } while (0);
    return result;
}
# 1043 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
# 1 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/ctype.h" 1







int isalnum (int __c);
int isalpha (int __c);
int iscntrl (int __c);
int isdigit (int __c);
int isgraph (int __c);
int islower (int __c);
int isprint (int __c);
int ispunct (int __c);
int isspace (int __c);
int isupper (int __c);
int isxdigit (int __c);
int tolower (int __c);
int toupper (int __c);


int isblank (int __c);



int isascii (int __c);
int toascii (int __c);
# 43 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/ctype.h"
const

extern char * const __ctype_ptr__;
# 109 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/ctype.h"
extern const char _ctype_[];


# 1044 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 2
# 1056 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
static int conv_num(const char * *, int *, int, int);

static const char *day[7] = {
    "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday",
    "Friday", "Saturday"
};

static const char *abday[7] = {
    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
};

static const char *mon[12] = {
    "January", "February", "March", "April", "May", "June", "July",
    "August", "September", "October", "November", "December"
};

static const char *abmon[12] = {
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
};

static const char *am_pm[2] = {
    "AM", "PM"
};


static int arg_strcasecmp(const char *s1, const char *s2)
{
    const unsigned char *us1 = (const unsigned char *)s1;
    const unsigned char *us2 = (const unsigned char *)s2;
    while (__extension__ ({ __typeof__ (*us1) __x = (*us1); ((((__ctype_ptr__+sizeof(""[__x]))[(int)(__x)])&(01|02))==01) ? (int) __x - 'A' + 'a' : (int) __x;}) == __extension__ ({ __typeof__ (*us2++) __x = (*us2++); ((((__ctype_ptr__+sizeof(""[__x]))[(int)(__x)])&(01|02))==01) ? (int) __x - 'A' + 'a' : (int) __x;}))
        if (*us1++ == '\0')
            return 0;

    return __extension__ ({ __typeof__ (*us1) __x = (*us1); ((((__ctype_ptr__+sizeof(""[__x]))[(int)(__x)])&(01|02))==01) ? (int) __x - 'A' + 'a' : (int) __x;}) - __extension__ ({ __typeof__ (*--us2) __x = (*--us2); ((((__ctype_ptr__+sizeof(""[__x]))[(int)(__x)])&(01|02))==01) ? (int) __x - 'A' + 'a' : (int) __x;});
}


static int arg_strncasecmp(const char *s1, const char *s2, size_t n)
{
    if (n != 0)
    {
        const unsigned char *us1 = (const unsigned char *)s1;
        const unsigned char *us2 = (const unsigned char *)s2;
        do
        {
            if (__extension__ ({ __typeof__ (*us1) __x = (*us1); ((((__ctype_ptr__+sizeof(""[__x]))[(int)(__x)])&(01|02))==01) ? (int) __x - 'A' + 'a' : (int) __x;}) != __extension__ ({ __typeof__ (*us2++) __x = (*us2++); ((((__ctype_ptr__+sizeof(""[__x]))[(int)(__x)])&(01|02))==01) ? (int) __x - 'A' + 'a' : (int) __x;}))
                return __extension__ ({ __typeof__ (*us1) __x = (*us1); ((((__ctype_ptr__+sizeof(""[__x]))[(int)(__x)])&(01|02))==01) ? (int) __x - 'A' + 'a' : (int) __x;}) - __extension__ ({ __typeof__ (*--us2) __x = (*--us2); ((((__ctype_ptr__+sizeof(""[__x]))[(int)(__x)])&(01|02))==01) ? (int) __x - 'A' + 'a' : (int) __x;});

            if (*us1++ == '\0')
                break;
        } while (--n != 0);
    }

    return 0;
}


char * arg_strptime(const char *buf, const char *fmt, struct tm *tm)
{
    char c;
    const char *bp;
    size_t len = 0;
    int alt_format, i, split_year = 0;

    bp = buf;

    while ((c = *fmt) != '\0') {

        alt_format = 0;


        if ((((__ctype_ptr__+sizeof(""[(int) c]))[(int)((int) c)])&010)) {
            while ((((__ctype_ptr__+sizeof(""[(int) *bp]))[(int)((int) *bp)])&010))
                bp++;

            fmt++;
            continue;
        }

        if ((c = *fmt++) != '%')
            goto literal;


again:
        switch (c = *fmt++)
        {
        case '%':
literal:
            if (c != *bp++)
                return (0);
            break;





        case 'E':
            { if (alt_format & ~(0)) return (0); };
            alt_format |= 0x01;
            goto again;

        case 'O':
            { if (alt_format & ~(0)) return (0); };
            alt_format |= 0x02;
            goto again;




        case 'c':
            { if (alt_format & ~(0x01)) return (0); };
            bp = arg_strptime(bp, "%x %X", tm);
            if (!bp)
                return (0);
            break;

        case 'D':
            { if (alt_format & ~(0)) return (0); };
            bp = arg_strptime(bp, "%m/%d/%y", tm);
            if (!bp)
                return (0);
            break;

        case 'R':
            { if (alt_format & ~(0)) return (0); };
            bp = arg_strptime(bp, "%H:%M", tm);
            if (!bp)
                return (0);
            break;

        case 'r':
            { if (alt_format & ~(0)) return (0); };
            bp = arg_strptime(bp, "%I:%M:%S %p", tm);
            if (!bp)
                return (0);
            break;

        case 'T':
            { if (alt_format & ~(0)) return (0); };
            bp = arg_strptime(bp, "%H:%M:%S", tm);
            if (!bp)
                return (0);
            break;

        case 'X':
            { if (alt_format & ~(0x01)) return (0); };
            bp = arg_strptime(bp, "%H:%M:%S", tm);
            if (!bp)
                return (0);
            break;

        case 'x':
            { if (alt_format & ~(0x01)) return (0); };
            bp = arg_strptime(bp, "%m/%d/%y", tm);
            if (!bp)
                return (0);
            break;




        case 'A':
        case 'a':
            { if (alt_format & ~(0)) return (0); };
            for (i = 0; i < 7; i++) {

                len = strlen(day[i]);
                if (arg_strncasecmp(day[i], bp, len) == 0)
                    break;


                len = strlen(abday[i]);
                if (arg_strncasecmp(abday[i], bp, len) == 0)
                    break;
            }


            if (i == 7)
                return (0);

            tm->tm_wday = i;
            bp += len;
            break;

        case 'B':
        case 'b':
        case 'h':
            { if (alt_format & ~(0)) return (0); };
            for (i = 0; i < 12; i++) {

                len = strlen(mon[i]);
                if (arg_strncasecmp(mon[i], bp, len) == 0)
                    break;


                len = strlen(abmon[i]);
                if (arg_strncasecmp(abmon[i], bp, len) == 0)
                    break;
            }


            if (i == 12)
                return (0);

            tm->tm_mon = i;
            bp += len;
            break;

        case 'C':
            { if (alt_format & ~(0x01)) return (0); };
            if (!(conv_num(&bp, &i, 0, 99)))
                return (0);

            if (split_year) {
                tm->tm_year = (tm->tm_year % 100) + (i * 100);
            } else {
                tm->tm_year = i * 100;
                split_year = 1;
            }
            break;

        case 'd':
        case 'e':
            { if (alt_format & ~(0x02)) return (0); };
            if (!(conv_num(&bp, &tm->tm_mday, 1, 31)))
                return (0);
            break;

        case 'k':
            { if (alt_format & ~(0)) return (0); };

        case 'H':
            { if (alt_format & ~(0x02)) return (0); };
            if (!(conv_num(&bp, &tm->tm_hour, 0, 23)))
                return (0);
            break;

        case 'l':
            { if (alt_format & ~(0)) return (0); };

        case 'I':
            { if (alt_format & ~(0x02)) return (0); };
            if (!(conv_num(&bp, &tm->tm_hour, 1, 12)))
                return (0);
            if (tm->tm_hour == 12)
                tm->tm_hour = 0;
            break;

        case 'j':
            { if (alt_format & ~(0)) return (0); };
            if (!(conv_num(&bp, &i, 1, 366)))
                return (0);
            tm->tm_yday = i - 1;
            break;

        case 'M':
            { if (alt_format & ~(0x02)) return (0); };
            if (!(conv_num(&bp, &tm->tm_min, 0, 59)))
                return (0);
            break;

        case 'm':
            { if (alt_format & ~(0x02)) return (0); };
            if (!(conv_num(&bp, &i, 1, 12)))
                return (0);
            tm->tm_mon = i - 1;
            break;

        case 'p':
            { if (alt_format & ~(0)) return (0); };

            if (arg_strcasecmp(am_pm[0], bp) == 0) {
                if (tm->tm_hour > 11)
                    return (0);

                bp += strlen(am_pm[0]);
                break;
            }

            else if (arg_strcasecmp(am_pm[1], bp) == 0) {
                if (tm->tm_hour > 11)
                    return (0);

                tm->tm_hour += 12;
                bp += strlen(am_pm[1]);
                break;
            }


            return (0);

        case 'S':
            { if (alt_format & ~(0x02)) return (0); };
            if (!(conv_num(&bp, &tm->tm_sec, 0, 61)))
                return (0);
            break;

        case 'U':
        case 'W':
            { if (alt_format & ~(0x02)) return (0); };






            if (!(conv_num(&bp, &i, 0, 53)))
                return (0);
            break;

        case 'w':
            { if (alt_format & ~(0x02)) return (0); };
            if (!(conv_num(&bp, &tm->tm_wday, 0, 6)))
                return (0);
            break;

        case 'Y':
            { if (alt_format & ~(0x01)) return (0); };
            if (!(conv_num(&bp, &i, 0, 9999)))
                return (0);

            tm->tm_year = i - (1900);
            break;

        case 'y':
            { if (alt_format & ~(0x01 | 0x02)) return (0); };
            if (!(conv_num(&bp, &i, 0, 99)))
                return (0);

            if (split_year) {
                tm->tm_year = ((tm->tm_year / 100) * 100) + i;
                break;
            }
            split_year = 1;
            if (i <= 68)
                tm->tm_year = i + 2000 - (1900);
            else
                tm->tm_year = i + 1900 - (1900);
            break;




        case 'n':
        case 't':
            { if (alt_format & ~(0)) return (0); };
            while ((((__ctype_ptr__+sizeof(""[(int) *bp]))[(int)((int) *bp)])&010))
                bp++;
            break;


        default:
            return (0);
        }


    }


    return ((char *)bp);
}


static int conv_num(const char * *buf, int *dest, int llim, int ulim)
{
    int result = 0;


    int rulim = ulim;

    if (**buf < '0' || **buf > '9')
        return (0);

    do {
        result *= 10;
        result += *(*buf)++ - '0';
        rulim /= 10;
    } while ((result * 10 <= ulim) && rulim && **buf >= '0' && **buf <= '9');

    if (result < llim || result > ulim)
        return (0);

    *dest = result;
    return (1);
}
# 1477 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
static void arg_dbl_resetfn(struct arg_dbl *parent)
{
    do { if (0) dbg_printf ("%s:resetfn(%p)\n", "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c", parent); } while (0);
    parent->count = 0;
}


static int arg_dbl_scanfn(struct arg_dbl *parent, const char *argval)
{
    int errorcode = 0;

    if (parent->count == parent->hdr.maxcount)
    {

        errorcode = EMAXCOUNT;
    }
    else if (!argval)
    {



        parent->count++;
    }
    else
    {
        double val;
        char *end;


        val = strtod(argval, &end);


        if (*end == 0)
            parent->dval[parent->count++] = val;
        else
            errorcode = EBADDOUBLE;
    }

    do { if (0) dbg_printf ("%s:scanfn(%p) returns %d\n", "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c", parent, errorcode); } while (0);
    return errorcode;
}


static int arg_dbl_checkfn(struct arg_dbl *parent)
{
    int errorcode = (parent->count < parent->hdr.mincount) ? EMINCOUNT : 0;

    do { if (0) dbg_printf ("%s:checkfn(%p) returns %d\n", "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c", parent, errorcode); } while (0);
    return errorcode;
}


static void arg_dbl_errorfn(
    struct arg_dbl *parent,
    FILE *fp,
    int errorcode,
    const char *argval,
    const char *progname)
{
    const char *shortopts = parent->hdr.shortopts;
    const char *longopts = parent->hdr.longopts;
    const char *datatype = parent->hdr.datatype;


    argval = argval ? argval : "";

    fprintf(fp, "%s: ", progname);
    switch(errorcode)
    {
    case EMINCOUNT:
        fputs("missing option ", fp);
        arg_print_option(fp, shortopts, longopts, datatype, "\n");
        break;

    case EMAXCOUNT:
        fputs("excess option ", fp);
        arg_print_option(fp, shortopts, longopts, argval, "\n");
        break;

    case EBADDOUBLE:
        fprintf(fp, "invalid argument \"%s\" to option ", argval);
        arg_print_option(fp, shortopts, longopts, datatype, "\n");
        break;
    }
}


struct arg_dbl * arg_dbl0(
    const char * shortopts,
    const char * longopts,
    const char *datatype,
    const char *glossary)
{
    return arg_dbln(shortopts, longopts, datatype, 0, 1, glossary);
}


struct arg_dbl * arg_dbl1(
    const char * shortopts,
    const char * longopts,
    const char *datatype,
    const char *glossary)
{
    return arg_dbln(shortopts, longopts, datatype, 1, 1, glossary);
}


struct arg_dbl * arg_dbln(
    const char * shortopts,
    const char * longopts,
    const char *datatype,
    int mincount,
    int maxcount,
    const char *glossary)
{
    size_t nbytes;
    struct arg_dbl *result;


    maxcount = (maxcount < mincount) ? mincount : maxcount;

    nbytes = sizeof(struct arg_dbl)
             + (maxcount + 1) * sizeof(double);

    result = (struct arg_dbl *)malloc(nbytes);
    if (result)
    {
        size_t addr;
        size_t rem;


        result->hdr.flag = ARG_HASVALUE;
        result->hdr.shortopts = shortopts;
        result->hdr.longopts = longopts;
        result->hdr.datatype = datatype ? datatype : "<double>";
        result->hdr.glossary = glossary;
        result->hdr.mincount = mincount;
        result->hdr.maxcount = maxcount;
        result->hdr.parent = result;
        result->hdr.resetfn = (arg_resetfn *)arg_dbl_resetfn;
        result->hdr.scanfn = (arg_scanfn *)arg_dbl_scanfn;
        result->hdr.checkfn = (arg_checkfn *)arg_dbl_checkfn;
        result->hdr.errorfn = (arg_errorfn *)arg_dbl_errorfn;






        addr = (size_t)(result + 1);
        rem = addr % sizeof(double);
        result->dval = (double *)(addr + sizeof(double) - rem);
        do { if (0) dbg_printf ("addr=%p, dval=%p, sizeof(double)=%d rem=%d\n", addr, result->dval, (int)sizeof(double), (int)rem); } while (0);

        result->count = 0;
    }

    do { if (0) dbg_printf ("arg_dbln() returns %p\n", result); } while (0);
    return result;
}
# 1672 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
static void arg_end_resetfn(struct arg_end *parent)
{
    do { if (0) dbg_printf ("%s:resetfn(%p)\n", "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c", parent); } while (0);
    parent->count = 0;
}

static void arg_end_errorfn(
    void *parent,
    FILE *fp,
    int error,
    const char *argval,
    const char *progname)
{

    (void)parent;

    progname = progname ? progname : "";
    argval = argval ? argval : "";

    fprintf(fp, "%s: ", progname);
    switch(error)
    {
    case ARG_ELIMIT:
        fputs("too many errors to display", fp);
        break;
    case ARG_EMALLOC:
        fputs("insufficent memory", fp);
        break;
    case ARG_ENOMATCH:
        fprintf(fp, "unexpected argument \"%s\"", argval);
        break;
    case ARG_EMISSARG:
        fprintf(fp, "option \"%s\" requires an argument", argval);
        break;
    case ARG_ELONGOPT:
        fprintf(fp, "invalid option \"%s\"", argval);
        break;
    default:
        fprintf(fp, "invalid option \"-%c\"", error);
        break;
    }

    fputc('\n', fp);
}


struct arg_end * arg_end(int maxcount)
{
    size_t nbytes;
    struct arg_end *result;

    nbytes = sizeof(struct arg_end)
             + maxcount * sizeof(int)
             + maxcount * sizeof(void *)
             + maxcount * sizeof(char *);

    result = (struct arg_end *)malloc(nbytes);
    if (result)
    {

        result->hdr.flag = ARG_TERMINATOR;
        result->hdr.shortopts = 
# 1733 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                               ((void *)0)
# 1733 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                                   ;
        result->hdr.longopts = 
# 1734 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                               ((void *)0)
# 1734 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                                   ;
        result->hdr.datatype = 
# 1735 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                               ((void *)0)
# 1735 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                                   ;
        result->hdr.glossary = 
# 1736 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                               ((void *)0)
# 1736 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                                   ;
        result->hdr.mincount = 1;
        result->hdr.maxcount = maxcount;
        result->hdr.parent = result;
        result->hdr.resetfn = (arg_resetfn *)arg_end_resetfn;
        result->hdr.scanfn = 
# 1741 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                               ((void *)0)
# 1741 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                                   ;
        result->hdr.checkfn = 
# 1742 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                               ((void *)0)
# 1742 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                                   ;
        result->hdr.errorfn = (arg_errorfn *)arg_end_errorfn;


        result->error = (int *)(result + 1);


        result->parent = (void * *)(result->error + maxcount );


        result->argval = (const char * *)(result->parent + maxcount );
    }

    do { if (0) dbg_printf ("arg_end(%d) returns %p\n", maxcount, result); } while (0);
    return result;
}


void arg_print_errors(FILE * fp, struct arg_end * end, const char * progname)
{
    int i;
    do { if (0) dbg_printf ("arg_errors()\n"); } while (0);
    for (i = 0; i < end->count; i++)
    {
        struct arg_hdr *errorparent = (struct arg_hdr *)(end->parent[i]);
        if (errorparent->errorfn)
            errorparent->errorfn(end->parent[i],
                                 fp,
                                 end->error[i],
                                 end->argval[i],
                                 progname);
    }
}
# 1819 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
static void arg_file_resetfn(struct arg_file *parent)
{
    do { if (0) dbg_printf ("%s:resetfn(%p)\n", "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c", parent); } while (0);
    parent->count = 0;
}



static const char * arg_basename(const char *filename)
{
    const char *result = 
# 1829 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                        ((void *)0)
# 1829 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                            , *result1, *result2;




    result1 = (filename ? strrchr(filename, '/') : 
# 1834 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                                                             ((void *)0)
# 1834 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                                                                 );
    result2 = (filename ? strrchr(filename, '/') : 
# 1835 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                                                             ((void *)0)
# 1835 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                                                                 );

    if (result2)
        result = result2 + 1;

    if (result1)
        result = result1 + 1;

    if (!result)
        result = filename;


    if (result && ( strcmp(".", result) == 0 || strcmp("..", result) == 0 ))
        result = filename + strlen(filename);

    return result;
}



static const char * arg_extension(const char *basename)
{

    const char *result = (basename ? strrchr(basename, '.') : 
# 1858 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                                                             ((void *)0)
# 1858 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                                                                 );


    if (basename && !result)
        result = basename + strlen(basename);


    if (basename && result == basename)
        result = basename + strlen(basename);


    if (basename && result && result[1] == '\0')
        result = basename + strlen(basename);

    return result;
}


static int arg_file_scanfn(struct arg_file *parent, const char *argval)
{
    int errorcode = 0;

    if (parent->count == parent->hdr.maxcount)
    {

        errorcode = EMAXCOUNT;
    }
    else if (!argval)
    {



        parent->count++;
    }
    else
    {
        parent->filename[parent->count] = argval;
        parent->basename[parent->count] = arg_basename(argval);
        parent->extension[parent->count] =
            arg_extension(parent->basename[parent->count]);
        parent->count++;
    }

    do { if (0) dbg_printf ("%s4:scanfn(%p) returns %d\n", "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c", parent, errorcode); } while (0);
    return errorcode;
}


static int arg_file_checkfn(struct arg_file *parent)
{
    int errorcode = (parent->count < parent->hdr.mincount) ? EMINCOUNT : 0;

    do { if (0) dbg_printf ("%s:checkfn(%p) returns %d\n", "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c", parent, errorcode); } while (0);
    return errorcode;
}


static void arg_file_errorfn(
    struct arg_file *parent,
    FILE *fp,
    int errorcode,
    const char *argval,
    const char *progname)
{
    const char *shortopts = parent->hdr.shortopts;
    const char *longopts = parent->hdr.longopts;
    const char *datatype = parent->hdr.datatype;


    argval = argval ? argval : "";

    fprintf(fp, "%s: ", progname);
    switch(errorcode)
    {
    case EMINCOUNT:
        fputs("missing option ", fp);
        arg_print_option(fp, shortopts, longopts, datatype, "\n");
        break;

    case EMAXCOUNT:
        fputs("excess option ", fp);
        arg_print_option(fp, shortopts, longopts, argval, "\n");
        break;

    default:
        fprintf(fp, "unknown error at \"%s\"\n", argval);
    }
}


struct arg_file * arg_file0(
    const char * shortopts,
    const char * longopts,
    const char *datatype,
    const char *glossary)
{
    return arg_filen(shortopts, longopts, datatype, 0, 1, glossary);
}


struct arg_file * arg_file1(
    const char * shortopts,
    const char * longopts,
    const char *datatype,
    const char *glossary)
{
    return arg_filen(shortopts, longopts, datatype, 1, 1, glossary);
}


struct arg_file * arg_filen(
    const char * shortopts,
    const char * longopts,
    const char *datatype,
    int mincount,
    int maxcount,
    const char *glossary)
{
    size_t nbytes;
    struct arg_file *result;


    maxcount = (maxcount < mincount) ? mincount : maxcount;

    nbytes = sizeof(struct arg_file)
             + sizeof(char *) * maxcount
             + sizeof(char *) * maxcount
             + sizeof(char *) * maxcount;

    result = (struct arg_file *)malloc(nbytes);
    if (result)
    {
        int i;


        result->hdr.flag = ARG_HASVALUE;
        result->hdr.shortopts = shortopts;
        result->hdr.longopts = longopts;
        result->hdr.glossary = glossary;
        result->hdr.datatype = datatype ? datatype : "<file>";
        result->hdr.mincount = mincount;
        result->hdr.maxcount = maxcount;
        result->hdr.parent = result;
        result->hdr.resetfn = (arg_resetfn *)arg_file_resetfn;
        result->hdr.scanfn = (arg_scanfn *)arg_file_scanfn;
        result->hdr.checkfn = (arg_checkfn *)arg_file_checkfn;
        result->hdr.errorfn = (arg_errorfn *)arg_file_errorfn;


        result->filename = (const char * *)(result + 1);
        result->basename = result->filename + maxcount;
        result->extension = result->basename + maxcount;
        result->count = 0;


        for (i = 0; i < maxcount; i++)
        {
            result->filename[i] = "";
            result->basename[i] = "";
            result->extension[i] = "";
        }
    }

    do { if (0) dbg_printf ("arg_filen() returns %p\n", result); } while (0);
    return result;
}
# 2055 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
# 1 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/limits.h" 1
# 131 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/limits.h"
# 1 "c:\\msys32\\opt\\xtensa-esp32-elf\\lib\\gcc\\xtensa-esp32-elf\\5.2.0\\include-fixed\\limits.h" 1 3 4
# 132 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/limits.h" 2
# 2056 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 2





static void arg_int_resetfn(struct arg_int *parent)
{
    do { if (0) dbg_printf ("%s:resetfn(%p)\n", "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c", parent); } while (0);
    parent->count = 0;
}
# 2078 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
static long int strtol0X(const char * str,
                         const char * *endptr,
                         char X,
                         int base)
{
    long int val;
    int s = 1;
    const char *ptr = str;


    while ((((__ctype_ptr__+sizeof(""[(int) *ptr]))[(int)((int) *ptr)])&010))
        ptr++;



    switch (*ptr)
    {
    case '+':
        ptr++;
        s = 1;
        break;
    case '-':
        ptr++;
        s = -1;
        break;
    default:
        s = 1;
        break;
    }



    if ((*ptr++) != '0')
    {

        *endptr = str;
        return 0;
    }

    if (__extension__ ({ __typeof__ ((int) *ptr++) __x = ((int) *ptr++); ((((__ctype_ptr__+sizeof(""[__x]))[(int)(__x)])&(01|02))==02) ? (int) __x - 'a' + 'A' : (int) __x;}) != __extension__ ({ __typeof__ ((int) X) __x = ((int) X); ((((__ctype_ptr__+sizeof(""[__x]))[(int)(__x)])&(01|02))==02) ? (int) __x - 'a' + 'A' : (int) __x;}))
    {

        *endptr = str;
        return 0;
    }



    val = strtol(ptr, (char * *)endptr, base);
    if (*endptr == ptr)
    {

        *endptr = str;
        return 0;
    }


    return s * val;
}




static int detectsuffix(const char *str, const char *suffix)
{

    while( __extension__ ({ __typeof__ ((int) *str) __x = ((int) *str); ((((__ctype_ptr__+sizeof(""[__x]))[(int)(__x)])&(01|02))==02) ? (int) __x - 'a' + 'A' : (int) __x;}) == __extension__ ({ __typeof__ ((int) *suffix) __x = ((int) *suffix); ((((__ctype_ptr__+sizeof(""[__x]))[(int)(__x)])&(01|02))==02) ? (int) __x - 'a' + 'A' : (int) __x;}) )
    {



        if (*str == '\0')
            return 1;


        str++;
        suffix++;
    }



    if (*suffix != 0)
        return 0;


    while ((((__ctype_ptr__+sizeof(""[(int) *str]))[(int)((int) *str)])&010))
        str++;


    return (*str == '\0') ? 1 : 0;
}


static int arg_int_scanfn(struct arg_int *parent, const char *argval)
{
    int errorcode = 0;

    if (parent->count == parent->hdr.maxcount)
    {

        errorcode = EMAXCOUNT;
    }
    else if (!argval)
    {



        parent->count++;
    }
    else
    {
        long int val;
        const char *end;


        val = strtol0X(argval, &end, 'X', 16);
        if (end == argval)
        {

            val = strtol0X(argval, &end, 'O', 8);
            if (end == argval)
            {

                val = strtol0X(argval, &end, 'B', 2);
                if (end == argval)
                {

                    val = strtol(argval, (char * *)&end, 10);
                    if (end == argval)
                    {

                        return EBADINT;
                    }
                }
            }
        }



        if ( val > 0x7fffffff || val < 
# 2217 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                                   (-0x7fffffff - 1) 
# 2217 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                                           )
            errorcode = 139;



        if (detectsuffix(end, "KB"))
        {
            if ( val > (0x7fffffff / 1024) || val < (
# 2224 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                                                 (-0x7fffffff - 1) 
# 2224 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                                                         / 1024) )
                errorcode = 139;
            else
                val *= 1024;
        }
        else if (detectsuffix(end, "MB"))
        {
            if ( val > (0x7fffffff / 1048576) || val < (
# 2231 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                                                    (-0x7fffffff - 1) 
# 2231 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                                                            / 1048576) )
                errorcode = 139;
            else
                val *= 1048576;
        }
        else if (detectsuffix(end, "GB"))
        {
            if ( val > (0x7fffffff / 1073741824) || val < (
# 2238 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                                                       (-0x7fffffff - 1) 
# 2238 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                                                               / 1073741824) )
                errorcode = 139;
            else
                val *= 1073741824;
        }
        else if (!detectsuffix(end, ""))
            errorcode = EBADINT;


        if (errorcode == 0)
            parent->ival[parent->count++] = val;
    }


    return errorcode;
}


static int arg_int_checkfn(struct arg_int *parent)
{
    int errorcode = (parent->count < parent->hdr.mincount) ? EMINCOUNT : 0;

    return errorcode;
}


static void arg_int_errorfn(
    struct arg_int *parent,
    FILE *fp,
    int errorcode,
    const char *argval,
    const char *progname)
{
    const char *shortopts = parent->hdr.shortopts;
    const char *longopts = parent->hdr.longopts;
    const char *datatype = parent->hdr.datatype;


    argval = argval ? argval : "";

    fprintf(fp, "%s: ", progname);
    switch(errorcode)
    {
    case EMINCOUNT:
        fputs("missing option ", fp);
        arg_print_option(fp, shortopts, longopts, datatype, "\n");
        break;

    case EMAXCOUNT:
        fputs("excess option ", fp);
        arg_print_option(fp, shortopts, longopts, argval, "\n");
        break;

    case EBADINT:
        fprintf(fp, "invalid argument \"%s\" to option ", argval);
        arg_print_option(fp, shortopts, longopts, datatype, "\n");
        break;

    case 139:
        fputs("integer overflow at option ", fp);
        arg_print_option(fp, shortopts, longopts, datatype, " ");
        fprintf(fp, "(%s is too large)\n", argval);
        break;
    }
}


struct arg_int * arg_int0(
    const char *shortopts,
    const char *longopts,
    const char *datatype,
    const char *glossary)
{
    return arg_intn(shortopts, longopts, datatype, 0, 1, glossary);
}


struct arg_int * arg_int1(
    const char *shortopts,
    const char *longopts,
    const char *datatype,
    const char *glossary)
{
    return arg_intn(shortopts, longopts, datatype, 1, 1, glossary);
}


struct arg_int * arg_intn(
    const char *shortopts,
    const char *longopts,
    const char *datatype,
    int mincount,
    int maxcount,
    const char *glossary)
{
    size_t nbytes;
    struct arg_int *result;


    maxcount = (maxcount < mincount) ? mincount : maxcount;

    nbytes = sizeof(struct arg_int)
             + maxcount * sizeof(int);

    result = (struct arg_int *)malloc(nbytes);
    if (result)
    {

        result->hdr.flag = ARG_HASVALUE;
        result->hdr.shortopts = shortopts;
        result->hdr.longopts = longopts;
        result->hdr.datatype = datatype ? datatype : "<int>";
        result->hdr.glossary = glossary;
        result->hdr.mincount = mincount;
        result->hdr.maxcount = maxcount;
        result->hdr.parent = result;
        result->hdr.resetfn = (arg_resetfn *)arg_int_resetfn;
        result->hdr.scanfn = (arg_scanfn *)arg_int_scanfn;
        result->hdr.checkfn = (arg_checkfn *)arg_int_checkfn;
        result->hdr.errorfn = (arg_errorfn *)arg_int_errorfn;


        result->ival = (int *)(result + 1);
        result->count = 0;
    }

    do { if (0) dbg_printf ("arg_intn() returns %p\n", result); } while (0);
    return result;
}
# 2402 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
static void arg_lit_resetfn(struct arg_lit *parent)
{
    do { if (0) dbg_printf ("%s:resetfn(%p)\n", "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c", parent); } while (0);
    parent->count = 0;
}


static int arg_lit_scanfn(struct arg_lit *parent, const char *argval)
{
    int errorcode = 0;
    if (parent->count < parent->hdr.maxcount )
        parent->count++;
    else
        errorcode = EMAXCOUNT;

    do { if (0) dbg_printf ("%s:scanfn(%p,%s) returns %d\n", "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c", parent, argval, errorcode); } while (0)
                          ;
    return errorcode;
}


static int arg_lit_checkfn(struct arg_lit *parent)
{
    int errorcode = (parent->count < parent->hdr.mincount) ? EMINCOUNT : 0;
    do { if (0) dbg_printf ("%s:checkfn(%p) returns %d\n", "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c", parent, errorcode); } while (0);
    return errorcode;
}


static void arg_lit_errorfn(
    struct arg_lit *parent,
    FILE *fp,
    int errorcode,
    const char *argval,
    const char *progname)
{
    const char *shortopts = parent->hdr.shortopts;
    const char *longopts = parent->hdr.longopts;
    const char *datatype = parent->hdr.datatype;

    switch(errorcode)
    {
    case EMINCOUNT:
        fprintf(fp, "%s: missing option ", progname);
        arg_print_option(fp, shortopts, longopts, datatype, "\n");
        fprintf(fp, "\n");
        break;

    case EMAXCOUNT:
        fprintf(fp, "%s: extraneous option ", progname);
        arg_print_option(fp, shortopts, longopts, datatype, "\n");
        break;
    }

    do { if (0) dbg_printf ("%s:errorfn(%p, %p, %d, %s, %s)\n", "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c", parent, fp, errorcode, argval, progname); } while (0)
                                            ;
}


struct arg_lit * arg_lit0(
    const char * shortopts,
    const char * longopts,
    const char * glossary)
{
    return arg_litn(shortopts, longopts, 0, 1, glossary);
}


struct arg_lit * arg_lit1(
    const char *shortopts,
    const char *longopts,
    const char *glossary)
{
    return arg_litn(shortopts, longopts, 1, 1, glossary);
}


struct arg_lit * arg_litn(
    const char *shortopts,
    const char *longopts,
    int mincount,
    int maxcount,
    const char *glossary)
{
    struct arg_lit *result;


    maxcount = (maxcount < mincount) ? mincount : maxcount;

    result = (struct arg_lit *)malloc(sizeof(struct arg_lit));
    if (result)
    {

        result->hdr.flag = 0;
        result->hdr.shortopts = shortopts;
        result->hdr.longopts = longopts;
        result->hdr.datatype = 
# 2498 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                               ((void *)0)
# 2498 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                                   ;
        result->hdr.glossary = glossary;
        result->hdr.mincount = mincount;
        result->hdr.maxcount = maxcount;
        result->hdr.parent = result;
        result->hdr.resetfn = (arg_resetfn *)arg_lit_resetfn;
        result->hdr.scanfn = (arg_scanfn *)arg_lit_scanfn;
        result->hdr.checkfn = (arg_checkfn *)arg_lit_checkfn;
        result->hdr.errorfn = (arg_errorfn *)arg_lit_errorfn;


        result->count = 0;
    }

    do { if (0) dbg_printf ("arg_litn() returns %p\n", result); } while (0);
    return result;
}
# 2549 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
struct arg_rem *arg_rem(const char *datatype, const char *glossary)
{
    struct arg_rem *result = (struct arg_rem *)malloc(sizeof(struct arg_rem));
    if (result)
    {
        result->hdr.flag = 0;
        result->hdr.shortopts = 
# 2555 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                               ((void *)0)
# 2555 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                                   ;
        result->hdr.longopts = 
# 2556 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                              ((void *)0)
# 2556 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                                  ;
        result->hdr.datatype = datatype;
        result->hdr.glossary = glossary;
        result->hdr.mincount = 1;
        result->hdr.maxcount = 1;
        result->hdr.parent = result;
        result->hdr.resetfn = 
# 2562 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                             ((void *)0)
# 2562 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                                 ;
        result->hdr.scanfn = 
# 2563 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                            ((void *)0)
# 2563 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                                ;
        result->hdr.checkfn = 
# 2564 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                             ((void *)0)
# 2564 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                                 ;
        result->hdr.errorfn = 
# 2565 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                             ((void *)0)
# 2565 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                                 ;
    }

    do { if (0) dbg_printf ("arg_rem() returns %p\n", result); } while (0);
    return result;
}
# 2664 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
typedef unsigned int TRexBool;
typedef struct TRex TRex;

typedef struct {
 const char *begin;
 int len;
} TRexMatch;

extern TRex *trex_compile(const char *pattern, const char **error, int flags);
extern void trex_free(TRex *exp);
extern TRexBool trex_match(TRex* exp, const char* text);
extern TRexBool trex_search(TRex* exp, const char* text, const char** out_begin, const char** out_end);
extern TRexBool trex_searchrange(TRex* exp, const char* text_begin, const char* text_end, const char** out_begin, const char** out_end);
extern int trex_getsubexpcount(TRex* exp);
extern TRexBool trex_getsubexp(TRex* exp, int n, TRexMatch *subexp);
# 2688 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
struct privhdr
{
    const char *pattern;
    int flags;
};


static void arg_rex_resetfn(struct arg_rex *parent)
{
    do { if (0) dbg_printf ("%s:resetfn(%p)\n", "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c", parent); } while (0);
    parent->count = 0;
}

static int arg_rex_scanfn(struct arg_rex *parent, const char *argval)
{
    int errorcode = 0;
    const char *error = 
# 2704 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                           ((void *)0)
# 2704 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                               ;
    TRex *rex = 
# 2705 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
               ((void *)0)
# 2705 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                   ;
    TRexBool is_match = 0;

    if (parent->count == parent->hdr.maxcount )
    {

        errorcode = EMAXCOUNT;
    }
    else if (!argval)
    {



        parent->count++;
    }
    else
    {
        struct privhdr *priv = (struct privhdr *)parent->hdr.priv;




        rex = trex_compile(priv->pattern, &error, priv->flags);
        is_match = trex_match(rex, argval);
        if (!is_match)
            errorcode = EREGNOMATCH;
        else
            parent->sval[parent->count++] = argval;

        trex_free(rex);
    }

    do { if (0) dbg_printf ("%s:scanfn(%p) returns %d\n","D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c",parent,errorcode); } while (0);
    return errorcode;
}

static int arg_rex_checkfn(struct arg_rex *parent)
{
    int errorcode = (parent->count < parent->hdr.mincount) ? EMINCOUNT : 0;






    return errorcode;
}

static void arg_rex_errorfn(struct arg_rex *parent,
                    FILE *fp,
                    int errorcode,
                    const char *argval,
                    const char *progname)
{
    const char *shortopts = parent->hdr.shortopts;
    const char *longopts = parent->hdr.longopts;
    const char *datatype = parent->hdr.datatype;


    argval = argval ? argval : "";

    fprintf(fp, "%s: ", progname);
    switch(errorcode)
    {
    case EMINCOUNT:
        fputs("missing option ", fp);
        arg_print_option(fp, shortopts, longopts, datatype, "\n");
        break;

    case EMAXCOUNT:
        fputs("excess option ", fp);
        arg_print_option(fp, shortopts, longopts, argval, "\n");
        break;

    case EREGNOMATCH:
        fputs("illegal value  ", fp);
        arg_print_option(fp, shortopts, longopts, argval, "\n");
        break;

    default:
    {



    }
    break;
    }
}


struct arg_rex * arg_rex0(const char * shortopts,
                          const char * longopts,
                          const char * pattern,
                          const char *datatype,
                          int flags,
                          const char *glossary)
{
    return arg_rexn(shortopts,
                    longopts,
                    pattern,
                    datatype,
                    0,
                    1,
                    flags,
                    glossary);
}

struct arg_rex * arg_rex1(const char * shortopts,
                          const char * longopts,
                          const char * pattern,
                          const char *datatype,
                          int flags,
                          const char *glossary)
{
    return arg_rexn(shortopts,
                    longopts,
                    pattern,
                    datatype,
                    1,
                    1,
                    flags,
                    glossary);
}


struct arg_rex * arg_rexn(const char * shortopts,
                          const char * longopts,
                          const char * pattern,
                          const char *datatype,
                          int mincount,
                          int maxcount,
                          int flags,
                          const char *glossary)
{
    size_t nbytes;
    struct arg_rex *result;
    struct privhdr *priv;
    int i;
    const char *error = 
# 2843 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                           ((void *)0)
# 2843 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                               ;
    TRex *rex = 
# 2844 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
               ((void *)0)
# 2844 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                   ;

    if (!pattern)
    {
        printf(
            "argtable: ERROR - illegal regular expression pattern \"(NULL)\"\n");
        printf("argtable: Bad argument table.\n");
        return 
# 2851 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
              ((void *)0)
# 2851 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                  ;
    }


    maxcount = (maxcount < mincount) ? mincount : maxcount;

    nbytes = sizeof(struct arg_rex)
             + sizeof(struct privhdr)
             + maxcount * sizeof(char *);

    result = (struct arg_rex *)malloc(nbytes);
    if (result == 
# 2862 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                 ((void *)0)
# 2862 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                     )
        return result;


    result->hdr.flag = ARG_HASVALUE;
    result->hdr.shortopts = shortopts;
    result->hdr.longopts = longopts;
    result->hdr.datatype = datatype ? datatype : pattern;
    result->hdr.glossary = glossary;
    result->hdr.mincount = mincount;
    result->hdr.maxcount = maxcount;
    result->hdr.parent = result;
    result->hdr.resetfn = (arg_resetfn *)arg_rex_resetfn;
    result->hdr.scanfn = (arg_scanfn *)arg_rex_scanfn;
    result->hdr.checkfn = (arg_checkfn *)arg_rex_checkfn;
    result->hdr.errorfn = (arg_errorfn *)arg_rex_errorfn;


    result->hdr.priv = result + 1;
    priv = (struct privhdr *)(result->hdr.priv);
    priv->pattern = pattern;
    priv->flags = flags;


    result->sval = (const char * *)(priv + 1);
    result->count = 0;


    for (i = 0; i < maxcount; i++)
        result->sval[i] = "";







    rex = trex_compile(priv->pattern, &error, priv->flags);
    if (rex == 
# 2900 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
              ((void *)0)
# 2900 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                  )
    {
        do { if (1) dbg_printf ("argtable: %s \"%s\"\n", error ? error : ("undefined"), priv->pattern); } while (0);
        do { if (1) dbg_printf ("argtable: Bad argument table.\n"); } while (0);
    }

    trex_free(rex);

    do { if (0) dbg_printf ("arg_rexn() returns %p\n", result); } while (0);
    return result;
}







# 1 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/setjmp.h" 1
# 10 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/setjmp.h"
# 1 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/machine/setjmp.h" 1


# 372 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/machine/setjmp.h"
typedef int jmp_buf[17];




# 11 "D:/ESP32/esp-idf-v3.1-rc1/components/newlib/include/setjmp.h" 2




void longjmp (jmp_buf __jmpb, int __retval)
   __attribute__ ((__noreturn__));



int setjmp (jmp_buf __jmpb);




# 2919 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 2
# 2968 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
typedef int TRexNodeType;

typedef struct tagTRexNode{
 TRexNodeType type;
 int left;
 int right;
 int next;
}TRexNode;

struct TRex{
 const char *_eol;
 const char *_bol;
 const char *_p;
 int _first;
 int _op;
 TRexNode *_nodes;
 int _nallocated;
 int _nsize;
 int _nsubexpr;
 TRexMatch *_matches;
 int _currsubexp;
 void *_jmpbuf;
 const char **_error;
 int _flags;
};

static int trex_list(TRex *exp);

static int trex_newnode(TRex *exp, TRexNodeType type)
{
 TRexNode n;
 int newid;
 n.type = type;
 n.next = n.right = n.left = -1;
 if(type == (0xFF +3))
  n.right = exp->_nsubexpr++;
 if(exp->_nallocated < (exp->_nsize + 1)) {
  exp->_nallocated *= 2;
  exp->_nodes = (TRexNode *)realloc(exp->_nodes, exp->_nallocated * sizeof(TRexNode));
 }
 exp->_nodes[exp->_nsize++] = n;
 newid = exp->_nsize - 1;
 return (int)newid;
}

static void trex_error(TRex *exp,const char *error)
{
 if(exp->_error) *exp->_error = error;
 longjmp(*((jmp_buf*)exp->_jmpbuf),-1);
}

static void trex_expect(TRex *exp, int n){
 if((*exp->_p) != n)
  trex_error(exp, ("expected paren"));
 exp->_p++;
}

static char trex_escapechar(TRex *exp)
{
 if(*exp->_p == ('\\')){
  exp->_p++;
  switch(*exp->_p) {
  case 'v': exp->_p++; return '\v';
  case 'n': exp->_p++; return '\n';
  case 't': exp->_p++; return '\t';
  case 'r': exp->_p++; return '\r';
  case 'f': exp->_p++; return '\f';
  default: return (*exp->_p++);
  }
 } else if(!(((__ctype_ptr__+sizeof(""[(int) *exp->_p]))[(int)((int) *exp->_p)])&(020|01|02|04|0200))) trex_error(exp,("letter expected"));
 return (*exp->_p++);
}

static int trex_charclass(TRex *exp,int classid)
{
 int n = trex_newnode(exp,(0xFF +7));
 exp->_nodes[n].left = classid;
 return n;
}

static int trex_charnode(TRex *exp,TRexBool isclass)
{
 char t;
 if(*exp->_p == ('\\')) {
  exp->_p++;
  switch(*exp->_p) {
   case 'n': exp->_p++; return trex_newnode(exp,'\n');
   case 't': exp->_p++; return trex_newnode(exp,'\t');
   case 'r': exp->_p++; return trex_newnode(exp,'\r');
   case 'f': exp->_p++; return trex_newnode(exp,'\f');
   case 'v': exp->_p++; return trex_newnode(exp,'\v');
   case 'a': case 'A': case 'w': case 'W': case 's': case 'S':
   case 'd': case 'D': case 'x': case 'X': case 'c': case 'C':
   case 'p': case 'P': case 'l': case 'u':
    {
    t = *exp->_p; exp->_p++;
    return trex_charclass(exp,t);
    }
   case 'b':
   case 'B':
    if(!isclass) {
     int node = trex_newnode(exp,(0xFF +13));
     exp->_nodes[node].left = *exp->_p;
     exp->_p++;
     return node;
    }

   default:
    t = *exp->_p; exp->_p++;
    return trex_newnode(exp,t);
  }
 }
 else if(!(((__ctype_ptr__+sizeof(""[(int) *exp->_p]))[(int)((int) *exp->_p)])&(020|01|02|04|0200))) {

  trex_error(exp,("letter expected"));
 }
 t = *exp->_p; exp->_p++;
 return trex_newnode(exp,t);
}
static int trex_class(TRex *exp)
{
 int ret = -1;
 int first = -1,chain;
 if(*exp->_p == ('^')){
  ret = trex_newnode(exp,(0xFF +8));
  exp->_p++;
 }else ret = trex_newnode(exp,(0xFF +6));

 if(*exp->_p == ']') trex_error(exp,("empty class"));
 chain = ret;
 while(*exp->_p != ']' && exp->_p != exp->_eol) {
  if(*exp->_p == '-' && first != -1){
   int r,t;
   if(*exp->_p++ == ']') trex_error(exp,("unfinished range"));
   r = trex_newnode(exp,(0xFF +9));
   if(first>*exp->_p) trex_error(exp,("invalid range"));
   if(exp->_nodes[first].type == (0xFF +7)) trex_error(exp,("cannot use character classes in ranges"));
   exp->_nodes[r].left = exp->_nodes[first].type;
   t = trex_escapechar(exp);
   exp->_nodes[r].right = t;
            exp->_nodes[chain].next = r;
   chain = r;
   first = -1;
  }
  else{
   if(first!=-1){
    int c = first;
    exp->_nodes[chain].next = c;
    chain = c;
    first = trex_charnode(exp,1);
   }
   else{
    first = trex_charnode(exp,1);
   }
  }
 }
 if(first!=-1){
  int c = first;
  exp->_nodes[chain].next = c;
  chain = c;
  first = -1;
 }

 exp->_nodes[ret].left = exp->_nodes[ret].next;
 exp->_nodes[ret].next = -1;
 return ret;
}

static int trex_parsenumber(TRex *exp)
{
 int ret = *exp->_p-'0';
 int positions = 10;
 exp->_p++;
 while((((__ctype_ptr__+sizeof(""[(int) *exp->_p]))[(int)((int) *exp->_p)])&04)) {
  ret = ret*10+(*exp->_p++-'0');
  if(positions==1000000000) trex_error(exp,("overflow in numeric constant"));
  positions *= 10;
 };
 return ret;
}

static int trex_element(TRex *exp)
{
 int ret = -1;
 switch(*exp->_p)
 {
 case '(': {
  int expr,newn;
  exp->_p++;


  if(*exp->_p =='?') {
   exp->_p++;
   trex_expect(exp,':');
   expr = trex_newnode(exp,(0xFF +4));
  }
  else
   expr = trex_newnode(exp,(0xFF +3));
  newn = trex_list(exp);
  exp->_nodes[expr].left = newn;
  ret = expr;
  trex_expect(exp,')');
     }
     break;
 case '[':
  exp->_p++;
  ret = trex_class(exp);
  trex_expect(exp,']');
  break;
 case ('$'): exp->_p++; ret = trex_newnode(exp,(0xFF +11));break;
 case ('.'): exp->_p++; ret = trex_newnode(exp,(0xFF +5));break;
 default:
  ret = trex_charnode(exp,0);
  break;
 }

 {
  TRexBool isgreedy = 0;
  unsigned short p0 = 0, p1 = 0;
  switch(*exp->_p){
   case ('*'): p0 = 0; p1 = 0xFFFF; exp->_p++; isgreedy = 1; break;
   case ('+'): p0 = 1; p1 = 0xFFFF; exp->_p++; isgreedy = 1; break;
   case ('?'): p0 = 0; p1 = 1; exp->_p++; isgreedy = 1; break;
   case '{':
    exp->_p++;
    if(!(((__ctype_ptr__+sizeof(""[(int) *exp->_p]))[(int)((int) *exp->_p)])&04)) trex_error(exp,("number expected"));
    p0 = (unsigned short)trex_parsenumber(exp);

    switch(*exp->_p) {
   case '}':
    p1 = p0; exp->_p++;
    break;
   case ',':
    exp->_p++;
    p1 = 0xFFFF;
    if((((__ctype_ptr__+sizeof(""[(int) *exp->_p]))[(int)((int) *exp->_p)])&04)){
     p1 = (unsigned short)trex_parsenumber(exp);
    }
    trex_expect(exp,'}');
    break;
   default:
    trex_error(exp,(", or } expected"));
  }

  isgreedy = 1;
  break;

  }
  if(isgreedy) {
   int nnode = trex_newnode(exp,(0xFF +1));
   exp->_nodes[nnode].left = ret;
   exp->_nodes[nnode].right = ((p0)<<16)|p1;
   ret = nnode;
  }
 }
 if((*exp->_p != ('|')) && (*exp->_p != ')') && (*exp->_p != ('*')) && (*exp->_p != ('+')) && (*exp->_p != '\0')) {
  int nnode = trex_element(exp);
  exp->_nodes[ret].next = nnode;
 }

 return ret;
}

static int trex_list(TRex *exp)
{
 int ret=-1,e;
 if(*exp->_p == ('^')) {
  exp->_p++;
  ret = trex_newnode(exp,(0xFF +12));
 }
 e = trex_element(exp);
 if(ret != -1) {
  exp->_nodes[ret].next = e;
 }
 else ret = e;

 if(*exp->_p == ('|')) {
  int temp,tright;
  exp->_p++;
  temp = trex_newnode(exp,(0xFF +2));
  exp->_nodes[temp].left = ret;
  tright = trex_list(exp);
  exp->_nodes[temp].right = tright;
  ret = temp;
 }
 return ret;
}

static TRexBool trex_matchcclass(int cclass,char ch)
{
    int c = ch;
 switch(cclass) {
 case 'a': return (((__ctype_ptr__+sizeof(""[c]))[(int)(c)])&(01|02))?1:0;
 case 'A': return !(((__ctype_ptr__+sizeof(""[c]))[(int)(c)])&(01|02))?1:0;
 case 'w': return ((((__ctype_ptr__+sizeof(""[c]))[(int)(c)])&(01|02|04)) || c == '_')?1:0;
 case 'W': return (!(((__ctype_ptr__+sizeof(""[c]))[(int)(c)])&(01|02|04)) && c != '_')?1:0;
 case 's': return (((__ctype_ptr__+sizeof(""[c]))[(int)(c)])&010)?1:0;
 case 'S': return !(((__ctype_ptr__+sizeof(""[c]))[(int)(c)])&010)?1:0;
 case 'd': return (((__ctype_ptr__+sizeof(""[c]))[(int)(c)])&04)?1:0;
 case 'D': return !(((__ctype_ptr__+sizeof(""[c]))[(int)(c)])&04)?1:0;
 case 'x': return (((__ctype_ptr__+sizeof(""[c]))[(int)(c)])&(0100|04))?1:0;
 case 'X': return !(((__ctype_ptr__+sizeof(""[c]))[(int)(c)])&(0100|04))?1:0;
 case 'c': return (((__ctype_ptr__+sizeof(""[c]))[(int)(c)])&040)?1:0;
 case 'C': return !(((__ctype_ptr__+sizeof(""[c]))[(int)(c)])&040)?1:0;
 case 'p': return (((__ctype_ptr__+sizeof(""[c]))[(int)(c)])&020)?1:0;
 case 'P': return !(((__ctype_ptr__+sizeof(""[c]))[(int)(c)])&020)?1:0;
 case 'l': return ((((__ctype_ptr__+sizeof(""[c]))[(int)(c)])&(01|02))==02)?1:0;
 case 'u': return ((((__ctype_ptr__+sizeof(""[c]))[(int)(c)])&(01|02))==01)?1:0;
 }
 return 0;
}

static TRexBool trex_matchclass(TRex* exp,TRexNode *node,char c)
{
 do {
  switch(node->type) {
   case (0xFF +9):
    if (exp->_flags & 1)
    {
     if(c >= __extension__ ({ __typeof__ (node->left) __x = (node->left); ((((__ctype_ptr__+sizeof(""[__x]))[(int)(__x)])&(01|02))==02) ? (int) __x - 'a' + 'A' : (int) __x;}) && c <= __extension__ ({ __typeof__ (node->right) __x = (node->right); ((((__ctype_ptr__+sizeof(""[__x]))[(int)(__x)])&(01|02))==02) ? (int) __x - 'a' + 'A' : (int) __x;})) return 1;
     if(c >= __extension__ ({ __typeof__ (node->left) __x = (node->left); ((((__ctype_ptr__+sizeof(""[__x]))[(int)(__x)])&(01|02))==01) ? (int) __x - 'A' + 'a' : (int) __x;}) && c <= __extension__ ({ __typeof__ (node->right) __x = (node->right); ((((__ctype_ptr__+sizeof(""[__x]))[(int)(__x)])&(01|02))==01) ? (int) __x - 'A' + 'a' : (int) __x;})) return 1;
    }
    else
    {
     if(c >= node->left && c <= node->right) return 1;
    }
    break;
   case (0xFF +7):
    if(trex_matchcclass(node->left,c)) return 1;
    break;
   default:
    if (exp->_flags & 1)
    {
     if (c == __extension__ ({ __typeof__ (node->type) __x = (node->type); ((((__ctype_ptr__+sizeof(""[__x]))[(int)(__x)])&(01|02))==01) ? (int) __x - 'A' + 'a' : (int) __x;}) || c == __extension__ ({ __typeof__ (node->type) __x = (node->type); ((((__ctype_ptr__+sizeof(""[__x]))[(int)(__x)])&(01|02))==02) ? (int) __x - 'a' + 'A' : (int) __x;})) return 1;
    }
    else
    {
     if(c == node->type)return 1;
    }

  }
 } while((node->next != -1) && (node = &exp->_nodes[node->next]));
 return 0;
}

static const char *trex_matchnode(TRex* exp,TRexNode *node,const char *str,TRexNode *next)
{

 TRexNodeType type = node->type;
 switch(type) {
 case (0xFF +1): {

  TRexNode *greedystop = 
# 3320 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                        ((void *)0)
# 3320 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                            ;
  int p0 = (node->right >> 16)&0x0000FFFF, p1 = node->right&0x0000FFFF, nmaches = 0;
  const char *s=str, *good = str;

  if(node->next != -1) {
   greedystop = &exp->_nodes[node->next];
  }
  else {
   greedystop = next;
  }

  while((nmaches == 0xFFFF || nmaches < p1)) {

   const char *stop;
   if(!(s = trex_matchnode(exp,&exp->_nodes[node->left],s,greedystop)))
    break;
   nmaches++;
   good=s;
   if(greedystop) {


    if(greedystop->type != (0xFF +1) ||
    (greedystop->type == (0xFF +1) && ((greedystop->right >> 16)&0x0000FFFF) != 0))
    {
     TRexNode *gnext = 
# 3344 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                      ((void *)0)
# 3344 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                          ;
     if(greedystop->next != -1) {
      gnext = &exp->_nodes[greedystop->next];
     }else if(next && next->next != -1){
      gnext = &exp->_nodes[next->next];
     }
     stop = trex_matchnode(exp,greedystop,s,gnext);
     if(stop) {

      if(p0 == p1 && p0 == nmaches) break;
      else if(nmaches >= p0 && p1 == 0xFFFF) break;
      else if(nmaches >= p0 && nmaches <= p1) break;
     }
    }
   }

   if(s >= exp->_eol)
    break;
  }
  if(p0 == p1 && p0 == nmaches) return good;
  else if(nmaches >= p0 && p1 == 0xFFFF) return good;
  else if(nmaches >= p0 && nmaches <= p1) return good;
  return 
# 3366 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
        ((void *)0)
# 3366 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
            ;
 }
 case (0xFF +2): {
   const char *asd = str;
   TRexNode *temp=&exp->_nodes[node->left];
   while( (asd = trex_matchnode(exp,temp,asd,
# 3371 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                                            ((void *)0)
# 3371 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                                                )) ) {
    if(temp->next != -1)
     temp = &exp->_nodes[temp->next];
    else
     return asd;
   }
   asd = str;
   temp = &exp->_nodes[node->right];
   while( (asd = trex_matchnode(exp,temp,asd,
# 3379 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                                            ((void *)0)
# 3379 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                                                )) ) {
    if(temp->next != -1)
     temp = &exp->_nodes[temp->next];
    else
     return asd;
   }
   return 
# 3385 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
         ((void *)0)
# 3385 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
             ;
   break;
 }
 case (0xFF +3):
 case (0xFF +4):{
   TRexNode *n = &exp->_nodes[node->left];
   const char *cur = str;
   int capture = -1;
   if(node->type != (0xFF +4) && node->right == exp->_currsubexp) {
    capture = exp->_currsubexp;
    exp->_matches[capture].begin = cur;
    exp->_currsubexp++;
   }

   do {
    TRexNode *subnext = 
# 3400 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                       ((void *)0)
# 3400 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                           ;
    if(n->next != -1) {
     subnext = &exp->_nodes[n->next];
    }else {
     subnext = next;
    }
    if(!(cur = trex_matchnode(exp,n,cur,subnext))) {
     if(capture != -1){
      exp->_matches[capture].begin = 0;
      exp->_matches[capture].len = 0;
     }
     return 
# 3411 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
           ((void *)0)
# 3411 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
               ;
    }
   } while((n->next != -1) && (n = &exp->_nodes[n->next]));

   if(capture != -1)
    exp->_matches[capture].len = cur - exp->_matches[capture].begin;
   return cur;
 }
 case (0xFF +13):
  if((str == exp->_bol && !(((__ctype_ptr__+sizeof(""[(int) *str]))[(int)((int) *str)])&010))
   || ((str == exp->_eol && !(((__ctype_ptr__+sizeof(""[(int) *(str-1)]))[(int)((int) *(str-1))])&010)))
   || ((!(((__ctype_ptr__+sizeof(""[(int) *str]))[(int)((int) *str)])&010) && (((__ctype_ptr__+sizeof(""[(int) *(str+1)]))[(int)((int) *(str+1))])&010)))
   || (((((__ctype_ptr__+sizeof(""[(int) *str]))[(int)((int) *str)])&010) && !(((__ctype_ptr__+sizeof(""[(int) *(str+1)]))[(int)((int) *(str+1))])&010))) ) {
   return (node->left == 'b')?str:
# 3424 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                                 ((void *)0)
# 3424 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                                     ;
  }
  return (node->left == 'b')?
# 3426 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                            ((void *)0)
# 3426 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                                :str;
 case (0xFF +12):
  if(str == exp->_bol) return str;
  return 
# 3429 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
        ((void *)0)
# 3429 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
            ;
 case (0xFF +11):
  if(str == exp->_eol) return str;
  return 
# 3432 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
        ((void *)0)
# 3432 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
            ;
 case (0xFF +5):
  str++;
  return str;
 case (0xFF +8):
 case (0xFF +6):
  if(trex_matchclass(exp,&exp->_nodes[node->left],*str)?(type == (0xFF +6)?1:0):(type == (0xFF +8)?1:0)) {
                        str++;
   return str;
  }
  return 
# 3442 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
        ((void *)0)
# 3442 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
            ;
 case (0xFF +7):
  if(trex_matchcclass(node->left,*str)) {
                        str++;
   return str;
  }
  return 
# 3448 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
        ((void *)0)
# 3448 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
            ;
 default:
  if (exp->_flags & 1)
  {
   if(*str != __extension__ ({ __typeof__ (node->type) __x = (node->type); ((((__ctype_ptr__+sizeof(""[__x]))[(int)(__x)])&(01|02))==01) ? (int) __x - 'A' + 'a' : (int) __x;}) && *str != __extension__ ({ __typeof__ (node->type) __x = (node->type); ((((__ctype_ptr__+sizeof(""[__x]))[(int)(__x)])&(01|02))==02) ? (int) __x - 'a' + 'A' : (int) __x;})) return 
# 3452 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                                                                        ((void *)0)
# 3452 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                                                                            ;
  }
  else
  {
   if (*str != node->type) return 
# 3456 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                                 ((void *)0)
# 3456 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                                     ;
  }
  str++;
  return str;
 }
 return 
# 3461 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
       ((void *)0)
# 3461 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
           ;
}


TRex *trex_compile(const char *pattern,const char **error,int flags)
{
 TRex *exp = (TRex *)malloc(sizeof(TRex));
 exp->_eol = exp->_bol = 
# 3468 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                        ((void *)0)
# 3468 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                            ;
 exp->_p = pattern;
 exp->_nallocated = (int)strlen(pattern) * sizeof(char);
 exp->_nodes = (TRexNode *)malloc(exp->_nallocated * sizeof(TRexNode));
 exp->_nsize = 0;
 exp->_matches = 0;
 exp->_nsubexpr = 0;
 exp->_first = trex_newnode(exp,(0xFF +3));
 exp->_error = error;
 exp->_jmpbuf = malloc(sizeof(jmp_buf));
 exp->_flags = flags;
 if(setjmp(*((jmp_buf*)exp->_jmpbuf)) == 0) {
  int res = trex_list(exp);
  exp->_nodes[exp->_first].left = res;
  if(*exp->_p!='\0')
   trex_error(exp,("unexpected character"));
# 3501 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
  exp->_matches = (TRexMatch *) malloc(exp->_nsubexpr * sizeof(TRexMatch));
  memset(exp->_matches,0,exp->_nsubexpr * sizeof(TRexMatch));
 }
 else{
  trex_free(exp);
  return 
# 3506 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
        ((void *)0)
# 3506 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
            ;
 }
 return exp;
}

void trex_free(TRex *exp)
{
 if(exp) {
  if(exp->_nodes) free(exp->_nodes);
  if(exp->_jmpbuf) free(exp->_jmpbuf);
  if(exp->_matches) free(exp->_matches);
  free(exp);
 }
}

TRexBool trex_match(TRex* exp,const char* text)
{
 const char* res = 
# 3523 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                      ((void *)0)
# 3523 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                          ;
 exp->_bol = text;
 exp->_eol = text + strlen(text);
 exp->_currsubexp = 0;
 res = trex_matchnode(exp,exp->_nodes,text,
# 3527 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                                          ((void *)0)
# 3527 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                                              );
 if(res == 
# 3528 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
          ((void *)0) 
# 3528 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
               || res != exp->_eol)
  return 0;
 return 1;
}

TRexBool trex_searchrange(TRex* exp,const char* text_begin,const char* text_end,const char** out_begin, const char** out_end)
{
 const char *cur = 
# 3535 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                      ((void *)0)
# 3535 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                          ;
 int node = exp->_first;
 if(text_begin >= text_end) return 0;
 exp->_bol = text_begin;
 exp->_eol = text_end;
 do {
  cur = text_begin;
  while(node != -1) {
   exp->_currsubexp = 0;
   cur = trex_matchnode(exp,&exp->_nodes[node],cur,
# 3544 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                                                  ((void *)0)
# 3544 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                                                      );
   if(!cur)
    break;
   node = exp->_nodes[node].next;
  }
  text_begin++;
 } while(cur == 
# 3550 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
               ((void *)0) 
# 3550 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                    && text_begin != text_end);

 if(cur == 
# 3552 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
          ((void *)0)
# 3552 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
              )
  return 0;

 --text_begin;

 if(out_begin) *out_begin = text_begin;
 if(out_end) *out_end = cur;
 return 1;
}

TRexBool trex_search(TRex* exp,const char* text, const char** out_begin, const char** out_end)
{
 return trex_searchrange(exp,text,text + strlen(text),out_begin,out_end);
}

int trex_getsubexpcount(TRex* exp)
{
 return exp->_nsubexpr;
}

TRexBool trex_getsubexp(TRex* exp, int n, TRexMatch *subexp)
{
 if( n<0 || n >= exp->_nsubexpr) return 0;
 *subexp = exp->_matches[n];
 return 1;
}
# 3613 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
static void arg_str_resetfn(struct arg_str *parent)
{
    do { if (0) dbg_printf ("%s:resetfn(%p)\n", "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c", parent); } while (0);
    parent->count = 0;
}


static int arg_str_scanfn(struct arg_str *parent, const char *argval)
{
    int errorcode = 0;

    if (parent->count == parent->hdr.maxcount)
    {

        errorcode = EMAXCOUNT;
    }
    else if (!argval)
    {



        parent->count++;
    }
    else
    {
        parent->sval[parent->count++] = argval;
    }

    do { if (0) dbg_printf ("%s:scanfn(%p) returns %d\n", "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c", parent, errorcode); } while (0);
    return errorcode;
}


static int arg_str_checkfn(struct arg_str *parent)
{
    int errorcode = (parent->count < parent->hdr.mincount) ? EMINCOUNT : 0;

    do { if (0) dbg_printf ("%s:checkfn(%p) returns %d\n", "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c", parent, errorcode); } while (0);
    return errorcode;
}


static void arg_str_errorfn(
    struct arg_str *parent,
    FILE *fp,
    int errorcode,
    const char *argval,
    const char *progname)
{
    const char *shortopts = parent->hdr.shortopts;
    const char *longopts = parent->hdr.longopts;
    const char *datatype = parent->hdr.datatype;


    argval = argval ? argval : "";

    fprintf(fp, "%s: ", progname);
    switch(errorcode)
    {
    case EMINCOUNT:
        fputs("missing option ", fp);
        arg_print_option(fp, shortopts, longopts, datatype, "\n");
        break;

    case EMAXCOUNT:
        fputs("excess option ", fp);
        arg_print_option(fp, shortopts, longopts, argval, "\n");
        break;
    }
}


struct arg_str * arg_str0(
    const char *shortopts,
    const char *longopts,
    const char *datatype,
    const char *glossary)
{
    return arg_strn(shortopts, longopts, datatype, 0, 1, glossary);
}


struct arg_str * arg_str1(
    const char *shortopts,
    const char *longopts,
    const char *datatype,
    const char *glossary)
{
    return arg_strn(shortopts, longopts, datatype, 1, 1, glossary);
}


struct arg_str * arg_strn(
    const char *shortopts,
    const char *longopts,
    const char *datatype,
    int mincount,
    int maxcount,
    const char *glossary)
{
    size_t nbytes;
    struct arg_str *result;




    maxcount = (maxcount < mincount) ? mincount : maxcount;

    nbytes = sizeof(struct arg_str)
             + maxcount * sizeof(char *);

    result = (struct arg_str *)malloc(nbytes);
    if (result)
    {
        int i;


        result->hdr.flag = ARG_HASVALUE;
        result->hdr.shortopts = shortopts;
        result->hdr.longopts = longopts;
        result->hdr.datatype = datatype ? datatype : "<string>";
        result->hdr.glossary = glossary;
        result->hdr.mincount = mincount;
        result->hdr.maxcount = maxcount;
        result->hdr.parent = result;
        result->hdr.resetfn = (arg_resetfn *)arg_str_resetfn;
        result->hdr.scanfn = (arg_scanfn *)arg_str_scanfn;
        result->hdr.checkfn = (arg_checkfn *)arg_str_checkfn;
        result->hdr.errorfn = (arg_errorfn *)arg_str_errorfn;


        result->sval = (const char * *)(result + 1);
        result->count = 0;


        for (i = 0; i < maxcount; i++)
            result->sval[i] = "";
    }

    do { if (0) dbg_printf ("arg_strn() returns %p\n", result); } while (0);
    return result;
}
# 3792 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
static
void arg_register_error(struct arg_end *end,
                        void *parent,
                        int error,
                        const char *argval)
{

    if (end->count < end->hdr.maxcount)
    {
        end->error[end->count] = error;
        end->parent[end->count] = parent;
        end->argval[end->count] = argval;
        end->count++;
    }
    else
    {
        end->error[end->hdr.maxcount - 1] = ARG_ELIMIT;
        end->parent[end->hdr.maxcount - 1] = end;
        end->argval[end->hdr.maxcount - 1] = 
# 3810 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                                            ((void *)0)
# 3810 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                                                ;
    }
}






static
int find_shortoption(struct arg_hdr * *table, char shortopt)
{
    int tabindex;
    for(tabindex = 0; !(table[tabindex]->flag & ARG_TERMINATOR); tabindex++)
    {
        if (table[tabindex]->shortopts &&
            strchr(table[tabindex]->shortopts, shortopt))
            return tabindex;
    }
    return -1;
}


struct longoptions
{
    int getoptval;
    int noptions;
    struct option *options;
};
# 3859 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
static
struct longoptions * alloc_longoptions(struct arg_hdr * *table)
{
    struct longoptions *result;
    size_t nbytes;
    int noptions = 1;
    size_t longoptlen = 0;
    int tabindex;
# 3878 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
    tabindex = 0;
    do
    {
        const char *longopts = table[tabindex]->longopts;
        longoptlen += (longopts ? strlen(longopts) : 0) + 1;
        while (longopts)
        {
            noptions++;
            longopts = strchr(longopts + 1, ',');
        }
    } while(!(table[tabindex++]->flag & ARG_TERMINATOR));





    nbytes = sizeof(struct longoptions)
             + sizeof(struct option) * noptions
             + longoptlen;
    result = (struct longoptions *)malloc(nbytes);
    if (result)
    {
        int option_index = 0;
        char *store;

        result->getoptval = 0;
        result->noptions = noptions;
        result->options = (struct option *)(result + 1);
        store = (char *)(result->options + noptions);

        for(tabindex = 0; !(table[tabindex]->flag & ARG_TERMINATOR); tabindex++)
        {
            const char *longopts = table[tabindex]->longopts;

            while(longopts && *longopts)
            {
                char *storestart = store;


                while (*longopts != 0 && *longopts != ',')
                    *store++ = *longopts++;
                *store++ = 0;
                if (*longopts == ',')
                    longopts++;


                result->options[option_index].name = storestart;
                result->options[option_index].flag = &(result->getoptval);
                result->options[option_index].val = tabindex;
                if (table[tabindex]->flag & ARG_HASOPTVALUE)
                    result->options[option_index].has_arg = 2;
                else if (table[tabindex]->flag & ARG_HASVALUE)
                    result->options[option_index].has_arg = 1;
                else
                    result->options[option_index].has_arg = 0;

                option_index++;
            }
        }

        result->options[option_index].name = 0;
        result->options[option_index].has_arg = 0;
        result->options[option_index].flag = 0;
        result->options[option_index].val = 0;
    }


    return result;
}

static
char * alloc_shortoptions(struct arg_hdr * *table)
{
    char *result;
    size_t len = 2;
    int tabindex;


    for(tabindex = 0; !(table[tabindex]->flag & ARG_TERMINATOR); tabindex++)
    {
        struct arg_hdr *hdr = table[tabindex];
        len += 3 * (hdr->shortopts ? strlen(hdr->shortopts) : 0);
    }

    result = malloc(len);
    if (result)
    {
        char *res = result;



        *res++ = ':';

        for(tabindex = 0; !(table[tabindex]->flag & ARG_TERMINATOR); tabindex++)
        {
            struct arg_hdr *hdr = table[tabindex];
            const char *shortopts = hdr->shortopts;
            while(shortopts && *shortopts)
            {
                *res++ = *shortopts++;
                if (hdr->flag & ARG_HASVALUE)
                    *res++ = ':';
                if (hdr->flag & ARG_HASOPTVALUE)
                    *res++ = ':';
            }
        }

        *res = 0;
    }


    return result;
}



static
int arg_endindex(struct arg_hdr * *table)
{
    int tabindex = 0;
    while (!(table[tabindex]->flag & ARG_TERMINATOR))
        tabindex++;
    return tabindex;
}


static
void arg_parse_tagged(int argc,
                      char * *argv,
                      struct arg_hdr * *table,
                      struct arg_end *endtable)
{
    struct longoptions *longoptions;
    char *shortoptions;
    int copt;





    longoptions = alloc_longoptions(table);
    shortoptions = alloc_shortoptions(table);
    if (!longoptions || !shortoptions)
    {

        arg_register_error(endtable, endtable, ARG_EMALLOC, 
# 4023 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                                                           ((void *)0)
# 4023 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                                                               );

        free(shortoptions);
        free(longoptions);
        return;
    }




    optind = 0;
    opterr = 0;


    while( (copt =
                getopt_long(argc, argv, shortoptions, longoptions->options,
                            
# 4039 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                           ((void *)0)
# 4039 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                               )) != -1)
    {






        switch(copt)
        {
        case 0:
        {
            int tabindex = longoptions->getoptval;
            void *parent = table[tabindex]->parent;

            if (optarg && optarg[0] == 0 &&
                (table[tabindex]->flag & ARG_HASVALUE))
            {

                arg_register_error(endtable, endtable, ARG_EMISSARG,
                                   argv[optind - 1]);

            }
            if (table[tabindex]->scanfn)
            {
                int errorcode = table[tabindex]->scanfn(parent, optarg);
                if (errorcode != 0)
                    arg_register_error(endtable, parent, errorcode, optarg);
            }
        }
        break;

        case '?':





            switch (optopt)
            {
            case 0:

                arg_register_error(endtable, endtable, ARG_ELONGOPT,
                                   argv[optind - 1]);
                break;
            default:

                arg_register_error(endtable, endtable, optopt, 
# 4086 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                                                              ((void *)0)
# 4086 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                                                                  );
                break;
            }
            break;

        case ':':




            arg_register_error(endtable, endtable, ARG_EMISSARG,
                               argv[optind - 1]);
            break;

        default:
        {

            int tabindex = find_shortoption(table, (char)copt);

            if (tabindex == -1)
            {


                arg_register_error(endtable, endtable, copt, 
# 4109 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                                                            ((void *)0)
# 4109 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                                                                );
            }
            else
            {
                if (table[tabindex]->scanfn)
                {
                    void *parent = table[tabindex]->parent;
                    int errorcode = table[tabindex]->scanfn(parent, optarg);
                    if (errorcode != 0)
                        arg_register_error(endtable, parent, errorcode, optarg);
                }
            }
            break;
        }
        }
    }

    free(shortoptions);
    free(longoptions);
}


static
void arg_parse_untagged(int argc,
                        char * *argv,
                        struct arg_hdr * *table,
                        struct arg_end *endtable)
{
    int tabindex = 0;
    int errorlast = 0;
    const char *optarglast = 
# 4139 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                            ((void *)0)
# 4139 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                                ;
    void *parentlast = 
# 4140 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                      ((void *)0)
# 4140 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                          ;


    while (!(table[tabindex]->flag & ARG_TERMINATOR))
    {
        void *parent;
        int errorcode;


        if (optind >= argc)
        {

            return;
        }


        if (table[tabindex]->longopts || table[tabindex]->shortopts)
        {

            tabindex++;
            continue;
        }


        if (!(table[tabindex]->scanfn))
        {

            tabindex++;
            continue;
        }




        parent = table[tabindex]->parent;
        errorcode = table[tabindex]->scanfn(parent, argv[optind]);
        if (errorcode == 0)
        {


            optind++;


            errorlast = 0;
        }
        else
        {


            tabindex++;


            errorlast = errorcode;
            optarglast = argv[optind];
            parentlast = parent;
        }

    }


    if (errorlast)
    {
        arg_register_error(endtable, parentlast, errorlast, optarglast);
        optind++;
    }



    while (optind < argc)
    {

        arg_register_error(endtable, endtable, ARG_ENOMATCH, argv[optind++]);
    }

    return;
}


static
void arg_parse_check(struct arg_hdr * *table, struct arg_end *endtable)
{
    int tabindex = 0;

    do
    {
        if (table[tabindex]->checkfn)
        {
            void *parent = table[tabindex]->parent;
            int errorcode = table[tabindex]->checkfn(parent);
            if (errorcode != 0)
                arg_register_error(endtable, parent, errorcode, 
# 4230 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                                                               ((void *)0)
# 4230 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                                                                   );
        }
    } while(!(table[tabindex++]->flag & ARG_TERMINATOR));
}


static
void arg_reset(void * *argtable)
{
    struct arg_hdr * *table = (struct arg_hdr * *)argtable;
    int tabindex = 0;

    do
    {
        if (table[tabindex]->resetfn)
            table[tabindex]->resetfn(table[tabindex]->parent);
    } while(!(table[tabindex++]->flag & ARG_TERMINATOR));
}


int arg_parse(int argc, char * *argv, void * *argtable)
{
    struct arg_hdr * *table = (struct arg_hdr * *)argtable;
    struct arg_end *endtable;
    int endindex;
    char * *argvcopy = 
# 4255 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                      ((void *)0)
# 4255 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                          ;




    arg_reset(argtable);


    endindex = arg_endindex(table);
    endtable = (struct arg_end *)table[endindex];




    if (argc == 0)
    {

        arg_parse_check(table, endtable);


        return endtable->count;
    }

    argvcopy = (char **)malloc(sizeof(char *) * (argc + 1));
    if (argvcopy)
    {
        int i;






        for (i = 0; i < argc; i++)
            argvcopy[i] = argv[i];

        argvcopy[argc] = 
# 4291 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                        ((void *)0)
# 4291 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                            ;


        arg_parse_tagged(argc, argvcopy, table, endtable);


        arg_parse_untagged(argc, argvcopy, table, endtable);


        if (endtable->count == 0)
            arg_parse_check(table, endtable);


        free(argvcopy);
    }
    else
    {

        arg_register_error(endtable, endtable, ARG_EMALLOC, 
# 4309 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                                                           ((void *)0)
# 4309 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                                                               );
    }

    return endtable->count;
}
# 4336 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
static
void arg_cat(char * *pdest, const char *src, size_t *pndest)
{
    char *dest = *pdest;
    char *end = dest + *pndest;


    while(dest < end && *dest != 0)
        dest++;


    while(dest < end && *src != 0)
        *dest++ = *src++;


    *dest = 0;


    *pndest = end - dest;
    *pdest = dest;
}


static
void arg_cat_option(char *dest,
                    size_t ndest,
                    const char *shortopts,
                    const char *longopts,
                    const char *datatype,
                    int optvalue)
{
    if (shortopts)
    {
        char option[3];



        option[0] = '-';
        option[1] = shortopts[0];
        option[2] = 0;

        arg_cat(&dest, option, &ndest);
        if (datatype)
        {
            arg_cat(&dest, " ", &ndest);
            if (optvalue)
            {
                arg_cat(&dest, "[", &ndest);
                arg_cat(&dest, datatype, &ndest);
                arg_cat(&dest, "]", &ndest);
            }
            else
                arg_cat(&dest, datatype, &ndest);
        }
    }
    else if (longopts)
    {
        size_t ncspn;


        arg_cat(&dest, "--", &ndest);


        ncspn = strcspn(longopts, ",");
        strncat(dest, longopts, (ncspn < ndest) ? ncspn : ndest);

        if (datatype)
        {
            arg_cat(&dest, "=", &ndest);
            if (optvalue)
            {
                arg_cat(&dest, "[", &ndest);
                arg_cat(&dest, datatype, &ndest);
                arg_cat(&dest, "]", &ndest);
            }
            else
                arg_cat(&dest, datatype, &ndest);
        }
    }
    else if (datatype)
    {
        if (optvalue)
        {
            arg_cat(&dest, "[", &ndest);
            arg_cat(&dest, datatype, &ndest);
            arg_cat(&dest, "]", &ndest);
        }
        else
            arg_cat(&dest, datatype, &ndest);
    }
}

static
void arg_cat_optionv(char *dest,
                     size_t ndest,
                     const char *shortopts,
                     const char *longopts,
                     const char *datatype,
                     int optvalue,
                     const char *separator)
{
    separator = separator ? separator : "";

    if (shortopts)
    {
        const char *c = shortopts;
        while(*c)
        {

            char shortopt[3];



            shortopt[0] = '-';
            shortopt[1] = *c;
            shortopt[2] = 0;

            arg_cat(&dest, shortopt, &ndest);
            if (*++c)
                arg_cat(&dest, separator, &ndest);
        }
    }


    if (shortopts && longopts)
        arg_cat(&dest, separator, &ndest);

    if (longopts)
    {
        const char *c = longopts;
        while(*c)
        {
            size_t ncspn;


            arg_cat(&dest, "--", &ndest);


            ncspn = strcspn(c, ",");
            strncat(dest, c, (ncspn < ndest) ? ncspn : ndest);
            c += ncspn;


            if (*c == ',')
            {
                arg_cat(&dest, separator, &ndest);
                c++;
            }
        }
    }

    if (datatype)
    {
        if (longopts)
            arg_cat(&dest, "=", &ndest);
        else if (shortopts)
            arg_cat(&dest, " ", &ndest);

        if (optvalue)
        {
            arg_cat(&dest, "[", &ndest);
            arg_cat(&dest, datatype, &ndest);
            arg_cat(&dest, "]", &ndest);
        }
        else
            arg_cat(&dest, datatype, &ndest);
    }
}



void arg_print_option(FILE *fp,
                      const char *shortopts,
                      const char *longopts,
                      const char *datatype,
                      const char *suffix)
{
    char syntax[200] = "";
    suffix = suffix ? suffix : "";


    arg_cat_optionv(syntax,
                    sizeof(syntax),
                    shortopts,
                    longopts,
                    datatype,
                    0,
                    "|");

    fputs(syntax, fp);
    fputs(suffix, fp);
}







static
void arg_print_gnuswitch(FILE *fp, struct arg_hdr * *table)
{
    int tabindex;
    const char *format1 = " -%c";
    const char *format2 = " [-%c";
    const char *suffix = "";


    for(tabindex = 0;
        table[tabindex] && !(table[tabindex]->flag & ARG_TERMINATOR);
        tabindex++)
    {

        if (table[tabindex]->mincount < 1)
            continue;


        if (table[tabindex]->shortopts == 
# 4553 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                                         ((void *)0)
# 4553 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                                             )
            continue;


        if (table[tabindex]->flag & ARG_HASVALUE)
            continue;


        fprintf(fp, format1, table[tabindex]->shortopts[0]);
        format1 = "%c";
        format2 = "[%c";
    }


    for(tabindex = 0;
        table[tabindex] && !(table[tabindex]->flag & ARG_TERMINATOR);
        tabindex++)
    {

        if (table[tabindex]->mincount > 0)
            continue;


        if (table[tabindex]->shortopts == 
# 4576 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                                         ((void *)0)
# 4576 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                                             )
            continue;


        if (table[tabindex]->flag & ARG_HASVALUE)
            continue;


        fprintf(fp, format2, table[tabindex]->shortopts[0]);
        format2 = "%c";
        suffix = "]";
    }

    fprintf(fp, "%s", suffix);
}


void arg_print_syntax(FILE *fp, void * *argtable, const char *suffix)
{
    struct arg_hdr * *table = (struct arg_hdr * *)argtable;
    int i, tabindex;


    arg_print_gnuswitch(fp, table);


    for(tabindex = 0;
        table[tabindex] && !(table[tabindex]->flag & ARG_TERMINATOR);
        tabindex++)
    {
        char syntax[200] = "";
        const char *shortopts, *longopts, *datatype;


        if (table[tabindex]->shortopts &&
            !(table[tabindex]->flag & ARG_HASVALUE))
            continue;

        shortopts = table[tabindex]->shortopts;
        longopts = table[tabindex]->longopts;
        datatype = table[tabindex]->datatype;
        arg_cat_option(syntax,
                       sizeof(syntax),
                       shortopts,
                       longopts,
                       datatype,
                       table[tabindex]->flag & ARG_HASOPTVALUE);

        if (strlen(syntax) > 0)
        {

            for (i = 0; i < table[tabindex]->mincount; i++)
                fprintf(fp, " %s", syntax);


            switch ( table[tabindex]->maxcount - table[tabindex]->mincount )
            {
            case 0:
                break;
            case 1:
                fprintf(fp, " [%s]", syntax);
                break;
            case 2:
                fprintf(fp, " [%s] [%s]", syntax, syntax);
                break;
            default:
                fprintf(fp, " [%s]...", syntax);
                break;
            }
        }
    }

    if (suffix)
        fprintf(fp, "%s", suffix);
}


void arg_print_syntaxv(FILE *fp, void * *argtable, const char *suffix)
{
    struct arg_hdr * *table = (struct arg_hdr * *)argtable;
    int i, tabindex;


    for(tabindex = 0;
        table[tabindex] && !(table[tabindex]->flag & ARG_TERMINATOR);
        tabindex++)
    {
        char syntax[200] = "";
        const char *shortopts, *longopts, *datatype;

        shortopts = table[tabindex]->shortopts;
        longopts = table[tabindex]->longopts;
        datatype = table[tabindex]->datatype;
        arg_cat_optionv(syntax,
                        sizeof(syntax),
                        shortopts,
                        longopts,
                        datatype,
                        table[tabindex]->flag & ARG_HASOPTVALUE,
                        "|");


        for (i = 0; i < table[tabindex]->mincount; i++)
            fprintf(fp, " %s", syntax);


        switch ( table[tabindex]->maxcount - table[tabindex]->mincount )
        {
        case 0:
            break;
        case 1:
            fprintf(fp, " [%s]", syntax);
            break;
        case 2:
            fprintf(fp, " [%s] [%s]", syntax, syntax);
            break;
        default:
            fprintf(fp, " [%s]...", syntax);
            break;
        }
    }

    if (suffix)
        fprintf(fp, "%s", suffix);
}


void arg_print_glossary(FILE *fp, void * *argtable, const char *format)
{
    struct arg_hdr * *table = (struct arg_hdr * *)argtable;
    int tabindex;

    format = format ? format : "  %-20s %s\n";
    for (tabindex = 0; !(table[tabindex]->flag & ARG_TERMINATOR); tabindex++)
    {
        if (table[tabindex]->glossary)
        {
            char syntax[200] = "";
            const char *shortopts = table[tabindex]->shortopts;
            const char *longopts = table[tabindex]->longopts;
            const char *datatype = table[tabindex]->datatype;
            const char *glossary = table[tabindex]->glossary;
            arg_cat_optionv(syntax,
                            sizeof(syntax),
                            shortopts,
                            longopts,
                            datatype,
                            table[tabindex]->flag & ARG_HASOPTVALUE,
                            ", ");
            fprintf(fp, format, syntax, glossary);
        }
    }
}
# 4763 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
void arg_print_formatted( FILE *fp,
                          const unsigned lmargin,
                          const unsigned rmargin,
                          const char *text )
{
    const unsigned textlen = strlen( text );
    unsigned line_start = 0;
    unsigned line_end = textlen + 1;
    const unsigned colwidth = (rmargin - lmargin) + 1;


    if ( line_end < line_start )
    { fprintf( fp, "%s\n", text ); }

    while (line_end - 1 > line_start )
    {



        while ( (((__ctype_ptr__+sizeof(""[(int) *(text + line_start)]))[(int)((int) *(text + line_start))])&010) )
        { line_start++; }

        if ((line_end - line_start) > colwidth )
        { line_end = line_start + colwidth; }


        while ( ( line_end > line_start )
                && ( line_end - line_start > colwidth )
                && !(((__ctype_ptr__+sizeof(""[(int) *(text + line_end)]))[(int)((int) *(text + line_end))])&010))
        { line_end--; }




        line_end--;


        while ( line_start < line_end )
        {
            fputc(*(text + line_start), fp );
            line_start++;
        }
        fputc( '\n', fp );


        if ( line_end + 1 < textlen )
        {
            unsigned i;

            for (i = 0; i < lmargin; i++ )
            { fputc( ' ', fp ); }

            line_end = textlen;
        }


        line_end++;

    }
}
# 4833 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
void arg_print_glossary_gnu(FILE *fp, void * *argtable )
{
    struct arg_hdr * *table = (struct arg_hdr * *)argtable;
    int tabindex;

    for(tabindex = 0; !(table[tabindex]->flag & ARG_TERMINATOR); tabindex++)
    {
        if (table[tabindex]->glossary)
        {
            char syntax[200] = "";
            const char *shortopts = table[tabindex]->shortopts;
            const char *longopts = table[tabindex]->longopts;
            const char *datatype = table[tabindex]->datatype;
            const char *glossary = table[tabindex]->glossary;

            if ( !shortopts && longopts )
            {

                memset( syntax, ' ', 4 );
                *(syntax + 4) = '\0';
            }

            arg_cat_optionv(syntax,
                            sizeof(syntax),
                            shortopts,
                            longopts,
                            datatype,
                            table[tabindex]->flag & ARG_HASOPTVALUE,
                            ", ");


            if ( strlen(syntax) > 25 )
            {
                fprintf( fp, "  %-25s %s\n", syntax, "" );
                *syntax = '\0';
            }

            fprintf( fp, "  %-25s ", syntax );
            arg_print_formatted( fp, 28, 79, glossary );
        }
    }

    fputc( '\n', fp );
}






int arg_nullcheck(void * *argtable)
{
    struct arg_hdr * *table = (struct arg_hdr * *)argtable;
    int tabindex;


    if (!table)
        return 1;

    tabindex = 0;
    do
    {

        if (!table[tabindex])
            return 1;
    } while(!(table[tabindex++]->flag & ARG_TERMINATOR));

    return 0;
}
# 4915 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
void arg_free(void * *argtable)
{
    struct arg_hdr * *table = (struct arg_hdr * *)argtable;
    int tabindex = 0;
    int flag;

    do
    {






        if (table[tabindex] == 
# 4929 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                              ((void *)0)
# 4929 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                                  )
            break;

        flag = table[tabindex]->flag;
        free(table[tabindex]);
        table[tabindex++] = 
# 4934 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                           ((void *)0)
# 4934 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                               ;

    } while(!(flag & ARG_TERMINATOR));
}


void arg_freetable(void * *argtable, size_t n)
{
    struct arg_hdr * *table = (struct arg_hdr * *)argtable;
    size_t tabindex = 0;

    for (tabindex = 0; tabindex < n; tabindex++)
    {
        if (table[tabindex] == 
# 4947 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                              ((void *)0)
# 4947 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                                  )
            continue;

        free(table[tabindex]);
        table[tabindex] = 
# 4951 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c" 3 4
                         ((void *)0)
# 4951 "D:/ESP32/esp-idf-v3.1-rc1/components/console/argtable3/argtable3.c"
                             ;
    };
}
